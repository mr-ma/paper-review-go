<!doctype html>
<html>
<head>
    <title>Taxonomy Relations</title>
    <script src="jquery.min.js"></script>
    <script src='cytoscape.min.js'></script> <!-- https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.2.6/cytoscape.min.js -->

    <link href="bootstrap.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap.min.js"></script>

    <link href="bootstrap-dialog.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap-dialog.min.js"></script>

    <script src='cytoscape-undo-redo.js'></script>
    <script src='cytoscape-clipboard.js'></script>
    <script src='cytoscape-graphml.js'></script>
    <script src='cytoscape-view-utilities.js'></script>

    <link href="cytoscape-context-menus.css" type="text/css" rel="stylesheet"/>
    <script src='cytoscape-context-menus.js'></script>
    <script src='cytoscape-cxtmenu.js'></script>
    <script src='cytoscape-autopan-on-drag.js'></script>
    <script src='cytoscape-edge-bend-editing.js'></script>
    <script src='CytoscapeEdgeEditation.js'></script>
    <script src='cytoscape-edgehandles.js'></script>
    <script src='cytoscape-expand-collapse.js'></script>

    <link href="cytoscape.js-navigator.css" type="text/css" rel="stylesheet"/>
    <script src='cytoscape-navigator.js'></script>

    <script src='konva.min.js'></script>
    <script src='cytoscape-node-resize.js'></script>

    <script src='cytoscape-noderesize.js'></script>
    <link href="cytoscape.js-panzoom.css" type="text/css" rel="stylesheet"/>
    <script src='cytoscape-panzoom.js'></script>

    <link href="jquery.qtip.min.css" type="text/css" rel="stylesheet"/>
    <script src='jquery.qtip.min.js'></script>
    <script src='cytoscape-qtip.js'></script>

    <script src='cytoscape-snap-to-grid.js'></script>

    <script src="multiselect.min.js"></script>

    <link href="loginForm.css" type="text/css" rel="stylesheet"/>

    <!-- promises -->
    <script src="bluebird.min.js"></script>
    <script src="error.js"></script>
<style>
    #cy {
        width: 100%; /* 100% */
        height: 100%; /* 100% */
        position: absolute;
        top: 0px;
        left: 0px;
    }
</style>

<script>
  function closeButton ( button ) {
    $(button).parentsUntil('modal').parent().modal('hide');
  }
</script>


</head>
<body>
  <div>
    <input type="button" class="btn btn-primary" id="getEdges" value="Save positions">
    <input type="button" class="btn btn-primary" id="merge" value="Merge nodes">
  </div>
	<div id="cy" style="margin-top:50px;"></div>

<div class="modal fade" id="default-modal" class="loginmodal" tabindex="-1" role="dialog" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="loginmodal-container">
      <span class="close-btn"><a href="javascript:void(0)" onclick="closeButton(this)">X</a></span>
      <h1 id="defaultModalTitle"></h1><br>
      <form id="defaultModalForm">
        <label for="defaultModalText" id="defaultModalLabel"></label>
        <input type="text" id="defaultModalText" value="">
        <div style="margin-top:20px;">
          <input type="submit" id="defaultModalButton" class="btn btn-success" value="Save">
        </div>
      </form>
    </div>
  </div>
</div>
<div class="modal fade" id="multiselect-modal" class="loginmodal" tabindex="-1" role="dialog" aria-labelledby="movePageLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="loginmodal-container">
      <span class="close-btn"><a href="javascript:void(0)" onclick="closeButton(this)">X</a></span>
      <h1 id="multiselectTitle"></h1><br>
      <form id="multiselectForm">
        <div class="row">
            <div class="col-xs-5">
                <label for="multiselect"></label>
                <select name="from[]" id="multiselect" class="multiselect" class="form-control" size="15" multiple="multiple"></select>
            </div>
            <div class="col-xs-2">
            <button type="button" id="multiselect_right_All_1" class="btn btn-block"><i class="glyphicon glyphicon-forward"></i></button>
            <button type="button" id="multiselect_right_Selected_1" class="btn btn-block"><i class="glyphicon glyphicon-chevron-right"></i></button>
            <button type="button" id="multiselect_left_Selected_1" class="btn btn-block"><i class="glyphicon glyphicon-chevron-left"></i></button>
            <button type="button" id="multiselect_left_All_1" class="btn btn-block"><i class="glyphicon glyphicon-backward"></i></button>
            </div>
            <div class="col-xs-5">
              <label for="multiselect_to"></label>
              <select name="to[]" id="multiselect_to" class="multiselect_to" class="form-control" size="15" multiple="multiple"></select>
            </div>
        </div>
        <div style="margin-top:20px;">
          <input type="submit" id="submitMultiselect" class="btn btn-success" value="Save">
        </div>
    </form>
    </div>
  </div>
</div>
<script>
  const COLOR_BLUE = '#00008B';
  const STYLES = [
      {
        selector: '.child',
        style: {
          width: 'data(width)',
          height: '50px',
          color: 'black',
          'border-width': '2px',
          'border-style': 'solid',
          'border-color': 'grey',
          shape: 'rectangle',
          'background-color': 'white',
          label: 'data(id)',
          'text-valign': 'center',
          'text-halign': 'center',
          'overlay-opacity': 0
        }
      },
      {
        selector: '.parent',
        style: {
          width: 'data(width)',
          height: '50px',
          color: 'black',
          'border-width': '2px',
          'border-style': 'solid',
          'border-color': 'lightgrey',
          shape: 'roundrectangle',
          'background-color': 'white',
          label: 'data(id)',
          'text-valign': 'center',
          'text-halign': 'center',
          'overlay-opacity': 0
        }
      },
      {
        selector: '.dimension',
        style: {
          'background-color': 'white',
          'border-color': COLOR_BLUE,
          'color': COLOR_BLUE,
          'border-width': '5px',
          label: 'data(id)',
          'text-valign': 'top',
          'text-halign': 'right',
          'text-margin-x': '5px',
          'text-margin-y': '-5px',
          'compound-sizing-wrt-labels': 'include',
          'min-height-bias-top': '100%',
          'min-height-bias-bottom': '100%',
          'min-width-bias-left': '100%',
          'min-width-bias-right': '100%',
          'overlay-opacity': 0
        }
      },
      {
        selector: 'edge',
        style: {
         'curve-style': 'segments', // bezier, unbundled-bezier, haystack, segments with: 'segment-distances': '10px 30px', 'segment-weights': '0.2 1.2',
         'segment-distances': '0px', //'segment-weights': '0.2 1.2'
         //'edge-distances': '5px',
         //'source-distance-from-node': '10px',
         //'target-distance-from-node': '10px',
         'width': 1,
         'target-arrow-color': 'black', // #ccc
         'line-color': 'black',
          label: 'data(annotation)',
          'text-margin-y': '-12px',
          'text-valign': 'center',
          'text-halign': 'center'
        }
      },
      {
        selector: '.Depends',
        style: {
          'target-arrow-shape': 'none',
          'target-arrow-fill': 'filled',
          'arrow-scale': 1
        }
      },
      {
        selector: '.DependsDirected',
        style: {
          'target-arrow-shape': 'triangle',
          'target-arrow-fill': 'filled',
          'arrow-scale': 1
        }
      },
      {
        selector: '.InstanceOf',
        style: {
          'target-arrow-shape': 'triangle',
          'target-arrow-fill': 'hollow',
          'arrow-scale': 2
        }
      },
      {
        selector: '.MemberOf',
        style: {
          'target-arrow-shape': 'diamond',
          'target-arrow-fill': 'hollow',
          'arrow-scale': 2.5
        }
      },
      {
        selector: '.PartOf',
        style: {
          'target-arrow-shape': 'diamond',
          'target-arrow-fill': 'filled',
          'arrow-scale': 2.5
        }
      }
    ];

  var cy;
  var isInterDimensional = true;
  var displayedDimension;

  function handleErrorHelper ( error ) {
    if (!!cy) cy.elements().trigger('qtiphide');
    handleError(error);
  }

  function savePositions ( cy, dimensions ) {
    //if (dimensions.length > 1) var saveURL = 'saveMajorPositions';
    //else var saveURL = 'savePositions';
    if (!displayedDimension) {
      handleErrorHelper('No dimension selected.');
      return;
    }
    var dimension = displayedDimension;
    if (displayedDimension == 'Interdimensional view') var saveURL = 'saveMajorPositions';
    else var saveURL = 'savePositions';
    var positions = [];
    cy.$('.parent,.child').forEach ( function ( node ) {
      var table = node.data('table');
      var position = node.position();
      positions.push({id: node.id(), table: table, x: '' + position.x, y: '' + position.y});
    });
    $.ajax
      ({
          type: "POST",
          //the url where you want to sent the userName and password to
          url: saveURL,
          dataType: 'json',
          contentType:'application/json',
          async: true,
          //json object to sent to the authentication url
          data: JSON.stringify({'taxonomy_id': 1, positions: positions, dimension: dimension}),
          success: function ( ) {
            console.log('Saved positions successfully.');
          }
      });
  }

  function traverseChildren ( cy, relations, parentID ) {
    relations.forEach ( function ( relation ) {
      if ((relation.relation == 'InstanceOf' || relation.relation == 'MemberOf' || relation.relation == 'PartOf') && relation.attributeDest == parentID) {
        var srcNode = cy.$('[id="' + relation.attributeSrc + '"]');
        if (srcNode.visible()) srcNode.style('display', 'none');
        else srcNode.style('display', 'element');
        traverseChildren(cy, relations, relation.attributeSrc);
      }
    });
  }

  function renameNode ( cy, ele ) {
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Enter new attribute name');
    $('#defaultModalLabel').html('Name:');
    $('#defaultModalText').val(ele.data('id'));
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var newAttributeName = $('#defaultModalText').val();
      if (newAttributeName == '' || cy.$('[id="' + newAttributeName + '"]').length > 0) {
        handleErrorHelper('This attribute name already exists in this domain.');
        $('#defaultModalButton').prop('disabled', false);
        return;
      }
      var previousName = ele.data('id');
      var renameURL = (ele.data('table') == 'dimension') ? 'renameDimension' : 'renameAttribute';
      $.ajax
        ({
            type: "POST",
            url: renameURL,
            dataType: 'json',
            contentType:'application/json',
            async: true,
            data: JSON.stringify({previousName: previousName, newName: newAttributeName}),
            success: function ( result ) {
              if (!result || !result.response || !result.response.success) {
                handleErrorHelper('Cannot rename attribute "' + previousName + '" to "' + newAttributeName + '". This name already exists.');
                $('#defaultModalButton').prop('disabled', false);
                return;
              }
              $('#defaultModalButton').prop('disabled', false);
              $('#default-modal').modal('hide');
              window.location.reload(false);
            }
        });
    });
    $('#default-modal').modal('show');
  }

  function switchMajor ( ele, dimension ) {
    var text = ele.id();
    var isMajor = ele.data('major') - 0;
    if (isNaN(isMajor)) {
      handleErrorHelper('Cannot read major attribute of "' + text + '".');
      return;
    }
    if (dimension == 'Interdimensional view') {
      handleErrorHelper('Cannot switch to/from major on the "Interdimensional view".');
      return;
    }
    $.ajax
      ({
        type: "POST",
        //the url where you want to sent the userName and password to
        url: 'updateMajor',
        dataType: 'json',
        contentType:'application/json',
        async: true,
        //json object to sent to the authentication url
        data: JSON.stringify({text: text, major: (isMajor == 1) ? 0 : 1}),
        success: function ( result ) {
          if (!result || !result.response || !result.response.success) {
            handleErrorHelper('Error occurred while updating the major attribute of "' + text + '".');
            return;
          }
          ele.classes((isMajor == 1) ? 'child' : 'parent');
          console.log('Switched the "major" property for attribute: "' + text + '".');
        }
    });
  }

  function addNode ( cy, ele, e, major ) {
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Enter attribute name');
    $('#defaultModalLabel').html('Name:');
    $('#defaultModalText').val('');
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var attributeName = $('#defaultModalText').val();
      if (attributeName == '' || cy.$('[id="' + attributeName + '"]').length > 0) {
        handleErrorHelper('This attribute name already exists in this domain.');
        $('#defaultModalButton').prop('disabled', false);
        return;
      }
      var request = {text: attributeName};
      if (isInterDimensional) {
        request.xMajor = '' + e.position.x;
        request.yMajor = '' + e.position.y;
        request.x = '';
        request.y = '';
      } else {
        request.x = '' + e.position.x;
        request.y = '' + e.position.y;
        request.xMajor = '';
        request.yMajor = '';
      }
      request.major = !!major ? 1 : 0;
      request.dimension = ele.id();
      console.log('sending post')
      $.ajax
        ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: 'addAttribute',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify(request),
            success: function ( result ) {
              if (!result || !result.response || !result.response.success) {
                handleErrorHelper('This name already exists in the taxonomy. Please choose a different one or delete the other node.');
                $('#defaultModalButton').prop('disabled', false);
                return;
              }
              cy.add({ data: { id: attributeName, table: 'attribute', citationCount: 0, parent: ele.id(), width: attributeName.length * 10, major: (!!major ? 1 : 0) }, classes: (!!major ? 'parent' : 'child'), position: e.position });
              $('#defaultModalButton').prop('disabled', false);
              $('#default-modal').modal('hide');
            }
        });
    });
    $('#default-modal').modal('show');
  }

  function addDimension ( cy, ele, e, major ) {
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Enter dimension name');
    $('#defaultModalLabel').html('Name:');
    $('#defaultModalText').val('');
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var dimensionName = $('#defaultModalText').val();
      if (dimensionName == '' || cy.$('[id="' + dimensionName + '"]').length > 0) {
        handleErrorHelper('This dimension name already exists in this domain.');
        $('#defaultModalButton').prop('disabled', false);
        return;
      }
      var request = {text: dimensionName};
      console.log('sending post')
      $.ajax
        ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: 'addDimension',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify(request),
            success: function ( result ) {
              if (!result || !result.response || !result.response.success) {
                handleErrorHelper('This name already exists in the taxonomy. Please choose a different one or delete the other dimension.');
                $('#defaultModalButton').prop('disabled', false);
                return;
              }
              var position = ele.position();
              cy.add({data: { id: dimensionName, table: 'dimension' }, classes: 'dimension', position: {x: position.x + ele.width(), y: position.y + ele.height()} });
              addNode(cy, cy.$('[id="' + dimensionName + '"]'), e, major);
              $('#defaultModalButton').prop('disabled', false);
              $('#default-modal').modal('hide');
            }
        });
    });
    $('#default-modal').modal('show');
  }

  function removeNodes ( cy, selecteds ) {
    var promises = [];
    selecteds.forEach ( function ( selected ) {
      var removePromise = new Promise ( function ( resolve, reject ) {
        var selectedID = selected.id();
        var selectedTable = selected.data('table');
        var removeURL = (selectedTable == 'dimension') ? 'removeDimension' : 'removeAttribute';
        $.ajax
          ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: removeURL,
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify({text: selectedID}),
            success: function ( result ) {
              if (!result || !result.response || !result.response.success) {
                if (selectedTable == 'dimension') handleErrorHelper('Error occurred while deleting dimension: "' + selectedID + '". Dimensions must be empty before they can be deleted.');
                else handleErrorHelper('Error occurred while deleting attribute: "' + selectedID + '".');
                return;
              }
              resolve();
            }
          });
      });
      promises.push(removePromise);
    });
    Promise.all(promises)
      .then ( function ( results ) {
        console.log('Removed ' + results.length + ' attribute' + (results.length > 1 ? 's' : '') + ' successfully.');
        selecteds.filter( function ( entry ) { return entry.data('table') == 'attribute'; }).forEach ( function ( selected ) {
          var api = selected.qtip('api');
          api.destroy();
          api.disable();
          cy.remove(selected);
        });
      }).catch ( function ( err ) {
        handleErrorHelper(err);
      });
  }

  function mergeNodes ( nodes ) {
    if (nodes.length != 2) {
      handleErrorHelper('Can only merge 2 attributes at a time.');
      return;
    }
    var text1 = nodes[0].data('id');
    var text2 = nodes[1].data('id');
    var dimension1 = nodes[0].data('parent');
    var dimension2 = nodes[1].data('parent');
    $.ajax
      ({
          type: "POST",
          //the url where you want to sent the userName and password to
          url: 'mergeAttributes',
          dataType: 'json',
          contentType:'application/json',
          async: true,
          //json object to sent to the authentication url
          data: JSON.stringify({text1: text1, text2: text2, dimension1: dimension1, dimension2: dimension2}),
          success: function ( result ) {
            if (!result || !result.response || !result.response.success) {
              handleErrorHelper('Error occurred while merging the attributes "' + text1 + '" and "' + text2 + '". Make sure that a node with the name "' + text1 + ':' + text2 + '" does not exist.');
              return;
            }
            window.location.reload(false);
          }
      });
  }

  function loadMultiselect ( data, title, callback ) {
    $('#multiselectTitle').html(title);
    $('label[for="multiselect"]').html('Source node');
    $('label[for="multiselect_to"]').html('Target node');
    $('#multiselect, #multiselect_to').html('');
    data.forEach ( function ( entry ) {
      var text = !!entry.text ? entry.text : (!!entry.citation ? entry.citation : '');
      var id = !!entry.id ? entry.id : text;
      if (text != '') $('#multiselect').append('<option value="' + id + '" data_relation="' + (!!entry.relation ? entry.relation : '') + '">' + text + '</option>');
    });
    $('#multiselectForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      console.log('done');
      var options = [];
      $('#multiselect_to option').each ( function ( index, entry ) {
        var element = {id: entry.value};
        var relation = $(entry).attr('data_relation');
        if (!!relation && relation !='') element.relation = relation;
        options.push(element);
      });
      callback(options);
    });
  }

  function loadCitationMappingMultiselect ( currentCitations, allCitations, title, callback ) {
    $('#multiselectTitle').html(title);
    $('label[for="multiselect"]').html('All citations');
    $('label[for="multiselect_to"]').html('Current citations');
    $('#multiselect, #multiselect_to').html('');
    var currentCitationTexts = [];
    currentCitations.forEach ( function ( entry ) {
      var text = entry.citation;
      var id = entry.id;
      if (text != '') {
        $('#multiselect_to').append('<option value="' + id + '">' + text + '</option>');
        currentCitationTexts.push(text);
      }
    });
    allCitations.forEach ( function ( entry ) {
      var text = entry.citation;
      var id = !!entry.id ? entry.id : text;
      if (text != '' && currentCitationTexts.indexOf(text) < 0) {
        $('#multiselect').append('<option value="' + id + '">' + text + '</option>');
      }
    });
    $('#multiselectForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      console.log('done');
      var options = [];
      $('#multiselect_to option').each ( function ( index, entry ) {
        var id = entry.value - 0;
        if (!isNaN(id)) options.push({id: id});
      });
      $('#multiselect-modal').modal('hide');
      callback(options);
    });
    if (!!cy) cy.elements().trigger('qtiphide');
    $('#multiselect-modal').modal('show');
  }

  function chooseParentRelations ( data, callback ) {
    if (!!data && data.length > 0) {
      loadMultiselect(data, 'Parents of<br>first node', function ( resultTmp ) {
        loadMultiselect(data, 'Parents of<br>second node', function ( resultTmp2 ) {
          var result = [];
          var result2 = [];
          resultTmp.forEach ( function ( entry ) {
            result.push({text: entry.id, relation: entry.relation});
          });
          resultTmp2.forEach ( function ( entry ) {
            result2.push({text: entry.id, relation: entry.relation});
          });
          callback([result, result2]);
        });
      });
    } else callback([[],[]]);
  }

  function chooseChildRelations ( data, callback ) {
    if (!!data && data.length > 0) {
      loadMultiselect(data, 'Children of<br>first node', function ( resultTmp ) {
        loadMultiselect(data, 'Children of<br>second node', function ( resultTmp2 ) {
          var result = [];
          var result2 = [];
          resultTmp.forEach ( function ( entry ) {
            result.push({text: entry.id, relation: entry.relation});
          });
          resultTmp2.forEach ( function ( entry ) {
            result2.push({text: entry.id, relation: entry.relation});
          });
          callback([result, result2]);
        });
      });
    } else callback([[],[]]);
  }

  function chooseCitationMappings ( data, callback ) {
    if (!!data && data.length > 0) {
      loadMultiselect(data, 'Citations of<br>first node', function ( resultTmp ) {
        loadMultiselect(data, 'Citations of<br>second node', function ( resultTmp2 ) {
          var result = [];
          var result2 = [];
          resultTmp.forEach ( function ( entry ) {
            var idNumber = entry.id - 0;
            if (!isNaN(idNumber)) result.push({id: idNumber});
          });
          resultTmp2.forEach ( function ( entry ) {
            var idNumber = entry.id - 0;
            if (!isNaN(idNumber)) result2.push({id: idNumber});
          });
          callback([result, result2]);
        });
      });
    } else callback([[],[]]);
  }

  function updateCitationMapping ( ele ) {
    var text = ele.data('id');
    $.get('citation', function ( allCitations ) {
      if (!allCitations) {
        handleErrorHelper('Cannot get citations from DB.');
        return;
      }
      $.ajax
        ({
          type: "POST",
          url: 'citationsPerAttribute',
          dataType: 'json',
          contentType:'application/json',
          async: true,
          data: JSON.stringify({attribute: text}),
          success: function ( citationsPerAttribute ) {
            if (!citationsPerAttribute) {
              handleErrorHelper('Cannot get citations of attribute "' + text + '" from DB.');
              return;
            }
            loadCitationMappingMultiselect(!!citationsPerAttribute.response ? citationsPerAttribute.response : [], !!allCitations.response ? allCitations.response : [], 'Citation mapping of "' + text + '"', function ( mappedCitations ) {
              $.ajax
                ({
                  type: "POST",
                  url: 'updateCitationMapping',
                  dataType: 'json',
                  contentType:'application/json',
                  async: true,
                  data: JSON.stringify({attribute: text, citations: mappedCitations}),
                  success: function ( result ) {
                    if (!result || !result.response || !result.response.success) {
                      handleErrorHelper('Cannot update citation mapping of attribute: "' + text + '". Can only map papers to leaf nodes.');
                      return;
                    }
                    ele.data('citationCount', mappedCitations.length);
                    console.log('Updated citations mapping of attribute "' + text + '" successfully, mapped papers: ' + mappedCitations.length);
                  }
              });
            });
          }
        });
    });
  }

  function forkNode ( node ) {
    var text = node.data('id');
    var isMajor = node.data('major');
    var dimension = node.data('parent');
    $.ajax
      ({
          type: "POST",
          //the url where you want to sent the userName and password to
          url: 'childRelationsPerAttribute',
          dataType: 'json',
          contentType:'application/json',
          async: true,
          //json object to sent to the authentication url
          data: JSON.stringify({'taxonomy_id': 1, text: text, dimension: dimension}),
          success: function ( childRelations ) {
            if (!childRelations) {
              handleErrorHelper('Error occurred while forking the attribute: ' + text);
              return;
            }
            $.ajax
              ({
                  type: "POST",
                  //the url where you want to sent the userName and password to
                  url: 'parentRelationsPerAttribute',
                  dataType: 'json',
                  contentType:'application/json',
                  async: true,
                  //json object to sent to the authentication url
                  data: JSON.stringify({'taxonomy_id': 1, text: text, dimension: dimension}),
                  success: function ( parentRelations ) {
                    if (!parentRelations) {
                      handleErrorHelper('Error occurred while forking the attribute: ' + text);
                      return;
                    }
                    $.ajax
                      ({
                          type: "POST",
                          //the url where you want to sent the userName and password to
                          url: 'citationsPerAttribute',
                          dataType: 'json',
                          contentType:'application/json',
                          async: true,
                          //json object to sent to the authentication url
                          data: JSON.stringify({attribute: text}),
                          success: function ( attributeCoverage ) {
                            if (!attributeCoverage) {
                              handleErrorHelper('Error occurred while forking the attribute: ' + text);
                              return;
                            }
                            if (!!parentRelations.response || childRelations.response || attributeCoverage.response) {
                              cy.elements().trigger('qtiphide');
                              if (!!cy) $('#multiselect-modal').modal('show');
                            }
                            chooseParentRelations(parentRelations.response, function ( parentResults ) {
                              chooseChildRelations(childRelations.response, function ( childResults ) {
                                chooseCitationMappings(attributeCoverage.response, function ( citationResults ) {
                                  $.ajax
                                    ({
                                        type: "POST",
                                        //the url where you want to sent the userName and password to
                                        url: 'forkAttribute',
                                        dataType: 'json',
                                        contentType:'application/json',
                                        async: true,
                                        //json object to sent to the authentication url
                                        data: JSON.stringify({text: text, dimension: dimension, parents1: parentResults[0], parents2: parentResults[1], children1: childResults[0], children2: childResults[1], citations1: citationResults[0], citations2: citationResults[1]}),
                                        success: function ( result ) {
                                          if (!result || !result.response || !result.response.success) {
                                            handleErrorHelper('Cannot fork attribute "' + text + '".');
                                            return;
                                          }
                                          $('#multiselect-modal').modal('hide');
                                          window.location.reload(false);
                                        }
                                    });
                                });
                              });
                            });
                          }
                        });
                  }
            });
          }
      });
  }

  function removeItem ( cy, selecteds, callback ) {
    var selected = selecteds[0];
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Remove item');
    $('#defaultModalLabel').html('Type the name of the item to delete it. (attributeSrc_attributeDest for edges):');
    $('#defaultModalText').val('');
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var deleteConfirmation = $('#defaultModalText').val();
      if (deleteConfirmation.toLowerCase().trim() != (selected.data('id')).toLowerCase().trim()) {
        handleErrorHelper('Type the name of the item to delete it. (attributeSrc_attributeDest for edges).');
        $('#defaultModalButton').prop('disabled', false);
        return;
      }
      $('#defaultModalButton').prop('disabled', false);
      $('#default-modal').modal('hide');
      callback(cy, selecteds);
    });
    $('#default-modal').modal('show');
  }

  function updateEdgeAnnotation ( cy, ele, sourceID, targetID, dimensions, isInterDimensional ) {
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Enter edge annotation');
    $('#defaultModalLabel').html('Annotation:');
    $('#defaultModalText').val(ele.data('annotation'));
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
        var annotation = $('#defaultModalText').val();
        $.ajax
          ({
              type: "POST",
              //the url where you want to sent the userName and password to
              url: 'updateTaxonomyRelationAnnotation',
              dataType: 'json',
              contentType:'application/json',
              async: true,
              //json object to sent to the authentication url
              data: JSON.stringify({'taxonomy_id': 1, attributeSrc: sourceID, attributeDest: targetID, dimension: (isInterDimensional ? 'Interdimensional view' : dimensions[0].text), text: annotation}),
              success: function ( result ) {
                if (!result || !result.response || !result.response.success) {
                   handleErrorHelper('Cannot update edge annotation.');
                   $('#defaultModalButton').prop('disabled', false);
                   return;
                 }
                console.log('Updated taxonomy relation annotation successfully, annotation: ' + annotation + ', source: ' + sourceID + ', target: ' + targetID + '.');
                ele.data('annotation', annotation);
                $('#defaultModalButton').prop('disabled', false);
                $('#default-modal').modal('hide');
              }
          });
    });
    $('#default-modal').modal('show');
  }

  function removeEdges ( cy, selecteds ) {
    var promises = [];
    selecteds.forEach ( function ( selected ) {
      var removePromise = new Promise ( function ( resolve, reject ) {
        $.ajax
          ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: 'removeTaxonomyRelation',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify({'taxonomy_id': 1, attributeSrc: selected.data('source'), attributeDest: selected.data('target'), dimension: selected.data('dimension'), text: selected.data('relation')}),
            success: function () {
              resolve();
            }
          });
      });
      promises.push(removePromise);
    });
    Promise.all(promises)
      .then ( function ( results ) {
        console.log('Removed ' + results.length + ' taxonomy relation' + (results.length > 1 ? 's' : '') + ' successfully.');
        selecteds.forEach ( function ( selected ) {
          var api = selected.qtip('api');
          api.destroy();
          api.disable();
          cy.remove(selected);
        });
      }).catch ( function ( err ) {
        handleErrorHelper(err);
      });
  }

  function createJSON ( dimensions, attributes, relations, relationTypes, citationCounts ) {
    console.log('creating json, sttr: ', attributes);
    isInterDimensional = dimensions.length > 1;
    var items = [];
    var menuItems = [];
    dimensions.forEach ( function ( dimension ) {
      if (isInterDimensional) items.push({data: { id: dimension.text, table: 'dimension' }, classes: 'dimension', position: {x: (dimension.xMajor - 0), y: (dimension.yMajor - 0)} });
      else items.push({data: { id: dimension.text, table: 'dimension' }, classes: 'dimension' }); // , style: { events: 'no' }
    });
    attributes.forEach ( function ( attribute ) {
      var x = attribute.x - 0;
      var y = attribute.y - 0;
      if (!isNaN(x) && !isNaN(y)) {
        var found = false;
        for ( var i = 0; i < citationCounts.length; i++ ) {
          if (citationCounts[i].attribute == attribute.text) {
            items.push({ data: { id: attribute.text, table: 'attribute', major: attribute.major, citationCount: citationCounts[i].citationCount, parent: attribute.dimension, width: attribute.text.length * 10 }, classes: (attribute.major == 1) ? 'parent' : 'child', position: {x: (attribute.x - 0), y: (attribute.y - 0)} });
            found = true;
            break;
          }
        }
        if (!found) {
          items.push({ data: { id: attribute.text, table: 'attribute', major: attribute.major, citationCount: 0, parent: attribute.dimension, width: attribute.text.length * 10 }, classes: (attribute.major == 1) ? 'parent' : 'child', position: {x: (attribute.x - 0), y: (attribute.y - 0)} });
        }
      }
    });
    relations.forEach ( function ( relation ) {
      var relationObj = { data: { id: relation.attributeSrc + '_' + relation.attributeDest, source: relation.attributeSrc, target: relation.attributeDest, annotation: !!relation.annotation ? relation.annotation : '', dimension: (isInterDimensional ? 'Interdimensional view' : dimensions[0].text), relation: relation.relation }, classes: relation.relation };
      var points = [];
      if (!!relation.edgeBendPoints) {
        var edgeBendPoints = relation.edgeBendPoints != '' ? relation.edgeBendPoints.split(';') : [];
        try {
          edgeBendPoints.forEach ( function ( edgeBendPoint ) {
            points.push(JSON.parse(edgeBendPoint.replace(/\'/g, '"')));
          });
        } catch ( err ) {
          console.log('JSON parse error of edge bend points: ', relation.edgeBendPoints);
        }
      }
      /*
      var x, y;
      var points = [];
      for ( var i = 0; i < edgePoints.length; i++ ) {
        if (i % 2 == 0) x = edgePoints[i];
        else points.push({x: x, y: edgePoints[i]});
      }
      */
      relationObj.data.bendPointPositions = points;
      items.push(relationObj);
    });


    var options = {
        // List of initial menu items
        menuItems: menuItems,
        // css classes that menu items will have
        menuItemClasses: [
          // add class names to this list
        ],
        // css classes that context menu will have
        contextMenuClasses: [
          // add class names to this list
        ]
    };
    //registerContextMenus();
    //cxtmenu( cytoscape );
    cy = cytoscape({  
      container: document.getElementById('cy'),
      elements: items,
      layout: {
        name: 'preset',
        zoom: 1,
        pan: {x: !!isInterDimensional ? ($(document).width() - 300) : 0, y: !!isInterDimensional ? $(document).height() : 0}
        //rows: 3
      },
      style: STYLES
    });
    var edgeBendEditingApi = cy.edgeBendEditing({ initBendPointsAutomatically: true });
    attributes.forEach ( function ( attribute ) {
      var nodeCommands = [];
      nodeCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
        content: 'Remove', // html/text content to be displayed in the menu
        select: function(ele){ // a function to execute when the command is selected
          removeItem(cy, [ele], removeNodes);
        },
        enabled: true // whether the command is selectable
      });
      nodeCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
        content: 'Rename', // html/text content to be displayed in the menu
        select: function(ele){ // a function to execute when the command is selected
          renameNode(cy, ele);
        },
        enabled: true // whether the command is selectable
      });
      if (!isInterDimensional) {
        nodeCommands.push({
          fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
          content: 'Switch major', // html/text content to be displayed in the menu
          select: function(ele){ // a function to execute when the command is selected
            switchMajor(ele);
          },
          enabled: true // whether the command is selectable
        });
      }
      nodeCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
        content: 'Fork', // html/text content to be displayed in the menu
        select: function(ele){ // a function to execute when the command is selected
          forkNode(ele);
        },
        enabled: true // whether the command is selectable
      });
      nodeCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
        content: 'Mapped papers', // html/text content to be displayed in the menu
        select: function(ele){ // a function to execute when the command is selected
          updateCitationMapping(ele);
        },
        enabled: true // whether the command is selectable
      });
/*
      relations.forEach ( function ( relation ) {
        if (attribute.text == relation.attributeDest) {
          nodeCommands.push({
            fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
            content: relation.attributeSrc, // html/text content to be displayed in the menu
            select: function(ele){ // a function to execute when the command is selected
              traverseChildren(cy, relations, relation.attributeSrc);
              var srcNode = cy.$('[id="' + relation.attributeSrc + '"]');
              if (srcNode.visible()) srcNode.style('display', 'none');
              else srcNode.style('display', 'element');
              cy.forceRender();
            },
            enabled: true // whether the command is selectable
          });
        }
      });
*/
      cy.cxtmenu({
        menuRadius: 100, // the radius of the circular menu in pixels
        selector: '[id="' + attribute.text + '"]', // elements matching this Cytoscape.js selector will trigger cxtmenus
        commands: nodeCommands, // function( ele ){ return [ /*...*/ ] }, // example function for commands
        fillColor: 'rgba(0, 0, 0, 0.75)', // the background colour of the menu
        activeFillColor: 'rgba(92, 194, 237, 0.75)', // the colour used to indicate the selected command
        activePadding: 20, // additional size in pixels for the active command
        indicatorSize: 24, // the size in pixels of the pointer to the active command
        separatorWidth: 3, // the empty spacing in pixels between successive commands
        spotlightPadding: 4, // extra spacing in pixels between the element and the spotlight
        minSpotlightRadius: 24, // the minimum radius in pixels of the spotlight
        maxSpotlightRadius: 38, // the maximum radius in pixels of the spotlight
        openMenuEvents: 'cxttapstart', // space-separated cytoscape events that will open the menu; only `cxttapstart` and/or `taphold` work here
        itemColor: 'white', // the colour of text in the command's content
        itemTextShadowColor: 'black', // the text shadow colour of the command's content
        zIndex: 9999, // the z-index of the ui div
        atMouse: false // draw menu at mouse position
      });
    });
    var edgeCommands = [];
    edgeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
      content: 'Remove', // html/text content to be displayed in the menu
      select: function(ele){ // a function to execute when the command is selected
        removeItem(cy, [ele], removeEdges);
      },
      enabled: true // whether the command is selectable
    });
    edgeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
      content: 'Annotation', // html/text content to be displayed in the menu
      title: 'Annotation',
      select: function(ele){ // a function to execute when the command is selected
        var sourceID = ele.data('source');
        var targetID = ele.data('target');
        updateEdgeAnnotation(cy, ele, sourceID, targetID, dimensions, isInterDimensional);
      },
      enabled: true // whether the command is selectable
    });
    relationTypes.forEach ( function ( relationType ) {
      edgeCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
        content: relationType.text, // html/text content to be displayed in the menu
        title: relationType.comment,
        select: function(ele){ // a function to execute when the command is selected
          var relation = ele.data('relation');
          if (!!relation && relation.split(relationType.text).length > 1) return;
          var sourceID = ele.data('source');
          var targetID = ele.data('target');
          $.ajax
            ({
                type: "POST",
                //the url where you want to sent the userName and password to
                url: 'updateTaxonomyRelationType',
                dataType: 'json',
                contentType:'application/json',
                async: true,
                //json object to sent to the authentication url
                data: JSON.stringify({'taxonomy_id': 1, attributeSrc: sourceID, attributeDest: targetID, dimension: (isInterDimensional ? 'Interdimensional view' : dimensions[0].text), text: relationType.text}),
                success: function ( citationsPerAttribute ) {
                  console.log('Updated taxonomy relation type successfully, type: ' + relationType.text + ', source: ' + sourceID + ', target: ' + targetID + '.');
                  ele.classes(relationType.text);
                  ele.data('relation', relationType.text);
                  edgeBendEditingApi.initBendPoints(ele);
                }
            });
        },
        enabled: true // whether the command is selectable
      });
    });
    cy.cxtmenu({
      menuRadius: 100, // the radius of the circular menu in pixels
      selector: 'edge', // elements matching this Cytoscape.js selector will trigger cxtmenus
      commands: edgeCommands, // function( ele ){ return [ /*...*/ ] }, // example function for commands
      fillColor: 'rgba(0, 0, 0, 0.75)', // the background colour of the menu
      activeFillColor: 'rgba(92, 194, 237, 0.75)', // the colour used to indicate the selected command
      activePadding: 20, // additional size in pixels for the active command
      indicatorSize: 24, // the size in pixels of the pointer to the active command
      separatorWidth: 3, // the empty spacing in pixels between successive commands
      spotlightPadding: 4, // extra spacing in pixels between the element and the spotlight
      minSpotlightRadius: 24, // the minimum radius in pixels of the spotlight
      maxSpotlightRadius: 38, // the maximum radius in pixels of the spotlight
      openMenuEvents: 'cxttapstart', // space-separated cytoscape events that will open the menu; only `cxttapstart` and/or `taphold` work here
      itemColor: 'white', // the colour of text in the command's content
      itemTextShadowColor: 'black', // the text shadow colour of the command's content
      zIndex: 9999, // the z-index of the ui div
      atMouse: false // draw menu at mouse position
    });
    var dimensionCommands = [];
    dimensionCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
      content: 'Remove', // html/text content to be displayed in the menu
      select: function(ele){ // a function to execute when the command is selected
        removeItem(cy, [ele], removeNodes);
      },
      enabled: true // whether the command is selectable
    });
    dimensionCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
      content: 'Rename', // html/text content to be displayed in the menu
      select: function(ele){ // a function to execute when the command is selected
        renameNode(cy, ele);
      },
      enabled: true // whether the command is selectable
    });
    if (!isInterDimensional) {
      dimensionCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
        content: 'Add node', // html/text content to be displayed in the menu
        title: 'Add node',
        select: function(ele, e){ // a function to execute when the command is selected
          e.preventDefault();
          addNode(cy, ele, e, false);
        },
        enabled: true // whether the command is selectable
      });
    }
    dimensionCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
      content: 'Add major node', // html/text content to be displayed in the menu
      title: 'Add major node',
      select: function(ele, e){ // a function to execute when the command is selected
        e.preventDefault();
        addNode(cy, ele, e, true);
      },
      enabled: true // whether the command is selectable
    });
    if (isInterDimensional) {
      dimensionCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)', // optional: custom background color for item
        content: 'Add dimension', // html/text content to be displayed in the menu
        title: 'Add dimension',
        select: function(ele, e){ // a function to execute when the command is selected
          e.preventDefault();
          addDimension(cy, ele, e, true);
        },
        enabled: true // whether the command is selectable
      });
    }
    cy.cxtmenu({
      menuRadius: 100, // the radius of the circular menu in pixels
      selector: '.dimension', // elements matching this Cytoscape.js selector will trigger cxtmenus
      commands: dimensionCommands, // function( ele ){ return [ /*...*/ ] }, // example function for commands
      fillColor: 'rgba(0, 0, 0, 0.75)', // the background colour of the menu
      activeFillColor: 'rgba(92, 194, 237, 0.75)', // the colour used to indicate the selected command
      activePadding: 20, // additional size in pixels for the active command
      indicatorSize: 24, // the size in pixels of the pointer to the active command
      separatorWidth: 3, // the empty spacing in pixels between successive commands
      spotlightPadding: 4, // extra spacing in pixels between the element and the spotlight
      minSpotlightRadius: 24, // the minimum radius in pixels of the spotlight
      maxSpotlightRadius: 38, // the maximum radius in pixels of the spotlight
      openMenuEvents: 'cxttapstart', // space-separated cytoscape events that will open the menu; only `cxttapstart` and/or `taphold` work here
      itemColor: 'white', // the colour of text in the command's content
      itemTextShadowColor: 'black', // the text shadow colour of the command's content
      zIndex: 9999, // the z-index of the ui div
      atMouse: true // draw menu at mouse position
    });
    var ur = cy.undoRedo();
    $(document).off("keydown").on("keydown", function (e) {
      if(e.which === 46) { // delete
          var selecteds = cy.$(':selected');
          if (selecteds.length == 0) return;
          if (selecteds.length > 1) {
            handleErrorHelper('Can only remove one item at a time');
            return;
          }
          var selecteds = cy.$("node:selected");
          if (selecteds.length > 0) {
            removeItem(cy, selecteds, removeNodes);$()
            return;
          }
          selecteds = cy.$("edge:selected");
          if (selecteds.length > 0) {
            removeItem(cy, selecteds, removeEdges);
          }
        }
        else if (e.ctrlKey && e.target.nodeName === 'BODY')
            if (e.which === 90)
                ur.undo();
            else if (e.which === 89)
                ur.redo();
    });
    cy.$('.parent,.child').each ( function ( entry, index ) {
      var titleText = '<span><label>Citations</label><input type="button" class="listCitations" value="List" name="' + entry.data('id') + '" style="margin-left:15px;"></span>';
      entry.qtip({
        content: {
          text: function ( event, api ) {
            return '' + this.data('citationCount');
          },
          title: {
            text: titleText,
            button: true
          }
        },
        position: {
            my: 'top center',
            // Position my top left...
            at: 'bottom center', // at the bottom right of...
            adjust: {
              cyViewport: true
            }
        },
        style: {
            classes: 'qtip-light',
            tip: {
                corner: true,
                width: 23,
                height: 12
            }
        },
        events: {
          render: function(event, api) {
            console.log("rendering")
            $('.listCitations').unbind().click( function () {
              event.preventDefault();
              var attribute = $(this).attr('name');
              if (!attribute) return;
              $.ajax
                ({
                    type: "POST",
                    url: 'citationsPerAttributeIncludingChildren',
                    dataType: 'json',
                    contentType:'application/json',
                    async: true,
                    data: JSON.stringify({attribute: attribute}),
                    success: function ( citationsPerAttribute ) {
                      if (!citationsPerAttribute) {
                        handleErrorHelper('Cannot get citations from DB for attribute: ' + attribute + '.');
                        return;
                      }
                      var citationTable = '<div style="max-height:500px;overflow-y:auto;"><table class="table table-striped"><thead><tr><th>Citation</th><th>References</th><th>Bib</th></tr></thead><tbody>';
                      var sumOfReferences = 0;
                      if (!!citationsPerAttribute.response) {
                        citationsPerAttribute.response.forEach ( function ( citationPerAttribute ) {
                          citationTable += '<tr><td>' + citationPerAttribute.citation + '</td><td>' + citationPerAttribute.referenceCount + '</td><td>' + citationPerAttribute.bib + '</td></tr>';
                          sumOfReferences += citationPerAttribute.referenceCount;
                        });
                      }
                      citationTable += '</tbody></table></div>';
                      if (sumOfReferences > 0) citationTable = '<div><p><b>Sum of references:</b>  ' + sumOfReferences + '</p></div>' + citationTable;
                      cy.elements().trigger('qtiphide');
                      BootstrapDialog.show({
                        title: 'Citations for attribute "' + attribute + '"',
                        message: citationTable
                      });
                    }
                });
            });
          }
        },
        show: {
          solo: true,
          event: 'qtipshow',
          cyBgOnly: true
        },
        hide: {
          event: 'qtiphide',
          cyViewport: true,
          cyBgOnly: true
        }
      });
    });
    //cy.panzoom();
    //cy.navigator();
    cy.edgehandles({handleNodes: '.child, .parent'});
    var viewUtilities = cy.viewUtilities({
      node: {
        highlighted: { 'color': COLOR_BLUE, 'border-color': COLOR_BLUE },
        unhighlighted: { 'opacity': 1 }
      },
      edge: {
        highlighted: { 'color': COLOR_BLUE, 'line-color': COLOR_BLUE },
        unhighlighted: { 'opacity': 1 }
      }
    });
    cy.on('select', '.parent,.child', function ( evt ) {
      var node = evt.target;
      node.trigger('qtipshow');
      var selecteds = cy.$('.parent:selected, .child:selected');
      if (selecteds.length > 2) {
        selecteds.each ( function ( selected ) {
          if (selected.data('id') != node.data('id')) selected.unselect();
        });
      }
      viewUtilities.highlight(node);
    });
    cy.on('select', 'edge', function ( evt ) {
      var edge = evt.target;
      viewUtilities.highlight(edge);
    });
    cy.on('unselect', '.parent,.child', function ( evt ) {
      var node = evt.target;
      node.trigger('qtiphide');
      viewUtilities.unhighlight(node);
    });
    cy.on('unselect', 'edge', function ( evt ) {
      var edge = evt.target;
      viewUtilities.unhighlight(edge);
    });
    cy.on('ehcomplete', function (event, sourceNode, targetNode, addedEles) {
      var sourceID = sourceNode.id();
      var targetID = targetNode.id();
      $.ajax
        ({
            type: "POST",
            url: 'addTaxonomyRelation',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            data: JSON.stringify({'taxonomy_id': 1, attributeSrc: sourceNode.id(), attributeDest: targetNode.id(), dimension: (isInterDimensional ? 'Interdimensional view' : dimensions[0].text), text: 'Depends'}),
            success: function ( result ) {
              console.log('Added taxonomy relation successfully, source: ' + sourceID + ', target: ' + targetID + '.');
            }
        });    
    });
    var expandCollapseApi = cy.expandCollapse({
      layoutBy: {
        name: "preset",
        animate: "end"
      },
      fisheye: false,
      animate: false,
      undoable: false,
      expandCollapseCuePosition: function ( e ) { var position = e.position(); return {x: position.x + e.width()/2 - 21, y: position.y - e.height()/2 - 5}; }, // 'top-left'
      expandCollapseCueSensitivity: 1.5,
      expandCollapseCueSize: 20, // 12
      expandCueImage: 'zoomInIcon.png',
      collapseCueImage: 'zoomOutIcon.png'
    });
    cy.$('.dimension').on('expandcollapse.beforecollapse', function ( e ) {
      cy.$('.parent,.child').each ( function ( node, index ) {
        var api = node.qtip('api');
        api.destroy();
        api.disable();
      });
      cy.destroy();
      if (isInterDimensional) {
        var dimText = this.id();
        showDimension(1, dimText);
        displayedDimension = dimText;
      } else {
        var dimText = 'Interdimensional view';
        showDimension(1, dimText);
        displayedDimension = dimText;
      }
    });
    cy.$('.dimension').on('expandcollapse.beforeexpand', function ( e ) {
      displayedDimension = 'Interdimensional view';
    });
    //var instance = cy.contextMenus( options );
    $('#clickMe').unbind().click ( function () {
      savePositions(cy, dimensions);
    });
    $('#getEdges').unbind().click ( function () {
      if (!displayedDimension) {
        handleErrorHelper('No dimension selected.');
        return;
      }
      var dimension = displayedDimension;
      var promises = [];
      cy.edges().forEach ( function ( entry ) {
        var segments = entry.segmentPoints();
        if (!!segments) {
          var segmentStr = '';
          segments.forEach ( function ( segment ) {
            segmentStr += (segmentStr != '' ? ';' : '') + JSON.stringify(segment);
          });
          segmentStr = segmentStr.replace(/\"/g, "'");
          var attributeSrc = entry.data('source');
          var attributeDest = entry.data('target');
          var saveEdgeBendPointsPromise = new Promise ( function ( resolve, reject ) {
            $.ajax
              ({
                  type: "POST",
                  url: 'saveEdgeBendPoints',
                  dataType: 'json',
                  contentType:'application/json',
                  async: true,
                  data: JSON.stringify({'taxonomy_id': 1, attributeSrc: attributeSrc, attributeDest: attributeDest, edgeBendPoints: segmentStr, dimension: dimension}),
                  success: function ( result ) {
                    resolve(result);
                  },
                  error: function () {
                    reject('Error occurred while saving edge bend points to DB.');
                  }
              });
            });
            promises.push(saveEdgeBendPointsPromise);
          }
      });
      if (promises.length == 0) {
        console.log('Saved edge bend points successfully.');
        savePositions(cy, dimensions);
        return;
      }
      Promise.all(promises)
        .then ( function ( results ) {
          console.log('Saved edge bend points successfully.');
          savePositions(cy, dimensions);
        }).catch ( function ( err ) {
          handleErrorHelper(err);
        });
    });
    $('#merge').unbind().click ( function () {
       var selecteds = cy.$(".parent:selected, .child:selected");
       if (selecteds.length < 2) {
         handleErrorHelper('Not enough attributes selected.');
         return;
       } else if (selecteds.length > 2) {
         handleErrorHelper('Can only merge 2 attributes at a time.');
         return;
       }
       mergeNodes(selecteds);
    });
    $('#multiselect-modal').on('shown.bs.modal', function () {
      console.log('shown')
      $('.multiselect').multiselect({
          rightAll: '#multiselect_right_All_1',
          right: '#multiselect_to',
          rightSelected: '#multiselect_right_Selected_1',
          leftSelected: '#multiselect_left_Selected_1',
          leftAll: '#multiselect_left_All_1',
          search: {
              left: '<input type="text" name="q" class="form-control" placeholder="Search..." />',
              right: '<input type="text" name="q" class="form-control" placeholder="Search..." />',
          },
          fireSearch: function(value) {
              return value.length > 3;
          }
      });
    });
    var qtipShown = false;
    $('#qtip').unbind().click ( function () {
      if (!qtipShown) {
        cy.elements().trigger('qtipshow');
        qtipShown = true;
      } else {
        cy.elements().trigger('qtiphide');
        qtipShown = false;
      }
    });
    /*
    cy.$('.parent,.child').on('click', function ( e ) {
      var nodeID = this.id();
      traverseChildren(cy, relations, nodeID);
      cy.forceRender();
    });
    */
    /*
    cy.$('.dimension').on('click', function ( e ) {
      var dimension = this.id();
      var url = window.location.href;
      if (url.split(dimension).length > 1) return; // TODO
      window.location.href = url.split('#').shift() + '#' + dimension;
      window.location.reload(false);
    });
    */
  }

    function showDimension ( taxonomyID, dimension ) {
      window.location.href = window.location.href.split('#').shift() + '#' + dimension;
      $.get('dimension', function ( dimensionResults ) {
        if (!dimensionResults || !dimensionResults.response) {
          console.log('Cannot get dimensions from DB.');
          return;
        }
        var request = {'taxonomy_id': taxonomyID};
        var attributeURL, attributeRelationsURL, dimensions;
        switch(dimension) {
          case 'Interdimensional view': attributeURL = 'majorAttributes'; attributeRelationsURL = 'interdimensionalRelations'; dimensions = dimensionResults.response; break;
          default: attributeURL = 'attributesPerDimension'; attributeRelationsURL = 'attributeRelations'; dimensions = [{text: dimension}]; request.dimension = dimension;
        }
        $.ajax
          ({
              type: "POST",
              //the url where you want to sent the userName and password to
              url: attributeURL,
              dataType: 'json',
              contentType:'application/json',
              async: true,
              //json object to sent to the authentication url
              data: JSON.stringify(request),
              success: function ( attributes ) {
                if (!attributes) {
                  console.log('Cannot get attributes from DB.');
                  return;
                }
                console.log(attributes.response)
                $.ajax
                  ({
                      type: "POST",
                      //the url where you want to sent the userName and password to
                      url: attributeRelationsURL,
                      dataType: 'json',
                      contentType:'application/json',
                      async: true,
                      //json object to sent to the authentication url
                      data: JSON.stringify(request),
                      success: function ( relations ) {
                        if (!relations) {
                          console.log('Cannot get attribute relations from DB.');
                          return;
                        }
                        $.get('relationTypes', function ( relationTypes ) {
                          if (!relationTypes) {
                            console.log('Cannot get relation types from DB.');
                            return;
                          }
                          $.get('citationCountsIncludingChildren', function ( citationCounts ) {
                              if (!citationCounts) {
                                console.log('Cannot get citation counts from DB.');
                                return;
                              }
                              createJSON(dimensions, !!attributes.response ? attributes.response : [], !!relations.response ? relations.response : [], !!relationTypes.response ? relationTypes.response : [], !!citationCounts.response ? citationCounts.response : []);
                              displayedDimension = dimension;
                          });
                        });
                      }
                  });
              }
          });
      });
    }

    function showDimensionRelations () {
      var request = {'taxonomy_id': taxonomyID};
      $.ajax
        ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: 'dimensionMajorAttributes',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify(request),
            success: function ( majorAttributes ) {
              showDimensions(majorAttributes.response);
            }
        });
    }

    $(document).ready( function () {
      $(this).on('contextmenu', function ( e ) {
        e.preventDefault();
      });
      var taxonomyID = 1;
      var dimension = window.location.href.split('#').pop().replace(/%20/g, ' ');
      if (dimension != '') {
        console.log('dimension: ' + dimension);
        showDimension(taxonomyID, dimension);
      }
    });
	</script>
</body>
</html>

