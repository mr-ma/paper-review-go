<!doctype html>
<html>
<head>
    <title>Taxonomy Relations</title>
    <script src="jquery.min.js" data-web="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src='cytoscape.min.js' data-web="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.2.8/cytoscape.min.js"></script>

    <link href="bootstrap.min.css" type="text/css" rel="stylesheet" data-web="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="bootstrap.min.js" data-web="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>

    <link href="bootstrap-dialog.min.css" type="text/css" rel="stylesheet" data-web="https://cdnjs.cloudflare.com/ajax/libs/bootstrap3-dialog/1.35.4/css/bootstrap-dialog.min.css">
    <script src="bootstrap-dialog.min.js" data-web="https://cdnjs.cloudflare.com/ajax/libs/bootstrap3-dialog/1.35.4/js/bootstrap-dialog.min.js"></script>

    <script src='cytoscape-undo-redo.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-undo-redo/master/cytoscape-undo-redo.js"></script>
    <script src='cytoscape-clipboard.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-clipboard/334db15f/cytoscape-clipboard.js"></script>
    <script src='cytoscape-graphml.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-graphml/02681992/cytoscape-graphml.js"></script>
    <script src='cytoscape-view-utilities.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-view-utilities/3844aa7d/cytoscape-view-utilities.js"></script>

    <link href="cytoscape-context-menus.css" type="text/css" rel="stylesheet" data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-context-menus/f9ec82cc/cytoscape-context-menus.css">
    <script src='cytoscape-context-menus.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-context-menus/f9ec82cc/cytoscape-context-menus.js"></script>
    <script src='cytoscape-cxtmenu.js' data-web="https://cdn.rawgit.com/cytoscape/cytoscape.js-cxtmenu/9b2eb1f6/cytoscape-cxtmenu.js"></script>
    <script src='cytoscape-autopan-on-drag.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-autopan-on-drag/f165a0a7/cytoscape-autopan-on-drag.js"></script>
    <script src='cytoscape-edge-bend-editing.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-edge-bend-editing/7ad9b679/cytoscape-edge-bend-editing.js"></script>
    <script src='CytoscapeEdgeEditation.js' data-web="https://cdn.rawgit.com/frankiex/cytoscape.js-edge-editation/c2c72909/CytoscapeEdgeEditation.js"></script>
    <script src='cytoscape-edgehandles.js' data-web="https://cdn.rawgit.com/cytoscape/cytoscape.js-edgehandles/601d4b04/cytoscape-edgehandles.js"></script>
    <script src='cytoscape-expand-collapse.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-expand-collapse/f2aeb7f2/cytoscape-expand-collapse.js"></script>

    <link href="cytoscape.js-navigator.css" type="text/css" rel="stylesheet" data-web="https://cdn.rawgit.com/cytoscape/cytoscape.js-navigator/39424808/cytoscape.js-navigator.css">
    <script src='cytoscape-navigator.js' data-web="https://cdn.rawgit.com/cytoscape/cytoscape.js-navigator/39424808/cytoscape-navigator.js"></script>

    <script src='konva.min.js' data-web="https://cdn.rawgit.com/konvajs/konva/8894d75a/konva.min.js"></script>
    <script src='cytoscape-node-resize.js' data-web="https://cdn.rawgit.com/iVis-at-Bilkent/cytoscape.js-node-resize/02fb8e04/cytoscape-node-resize.js"></script>

    <script src='cytoscape-noderesize.js' data-web="https://cdn.rawgit.com/jhonatandarosa/cytoscape.js-noderesize/fcfdda4c/cytoscape-noderesize.js"></script>
    <link href="cytoscape.js-panzoom.css" type="text/css" rel="stylesheet" data-web="https://cdn.rawgit.com/cytoscape/cytoscape.js-panzoom/11f0f050/cytoscape.js-panzoom.css">
    <script src='cytoscape-panzoom.js' data-web="https://cdn.rawgit.com/cytoscape/cytoscape.js-panzoom/11f0f050/cytoscape-panzoom.js"></script>

    <link href="jquery.qtip.min.css" type="text/css" rel="stylesheet" data-web="https://cdn.rawgit.com/qTip2/qTip2/eeffdbaa/dist/jquery.qtip.min.css">
    <script src='jquery.qtip.min.js' data-web="https://cdn.rawgit.com/qTip2/qTip2/eeffdbaa/dist/jquery.qtip.min.js"></script>
    <script src='cytoscape-qtip.js' data-web="https://cdn.rawgit.com/cytoscape/cytoscape.js-qtip/02ebf16c/cytoscape-qtip.js"></script>

    <script src='cytoscape-snap-to-grid.js' data-web="https://cdn.rawgit.com/guimeira/cytoscape-snap-to-grid/2c591548/cytoscape-snap-to-grid.js"></script>

    <script src="multiselect.min.js" data-web="https://cdn.rawgit.com/crlcu/multiselect/8b020061/dist/js/multiselect.min.js"></script>

    <script src="bluebird.min.js" data-web="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.1/bluebird.min.js"></script>

    <script src="FileSaver.min.js" data-web="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/1.3.3/FileSaver.min.js"></script>

    <script src="loadData.js"></script>
    <script src="exportHTML.js"></script>

    <link href="main.css" type="text/css" rel="stylesheet">
    <script src="userManagement.js"></script>
    <script src="error.js"></script>
<style>
    #cy {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 110px;
        left: 0px;
    }
</style>

<script>
  function closeButton ( button ) {
    $(button).parentsUntil('modal').parent().modal('hide');
  }
</script>


</head>
<body>
<div class="navbar"></div>
<div class="modals"></div>

  <div class="btn btn-group" role="group" aria-label="...">
    <button type="button" class="btn btn-default" id="exportPNG" title="Export PNG"><span class="glyphicon glyphicon-picture" value="Export PNG" ></span></button>
    <button type="button" class="btn btn-default" id="exportHTML" title="Export HTML"><span class="glyphicon glyphicon-file" value="Export HTML" ></span></button>
    <button type="button" class="btn btn-default" id="getEdges" title="Save Positions" style="display:none;"><span class="glyphicon glyphicon-floppy-disk" value="Save Positions" ></span></button>
    <button type="button" class="btn btn-default" id="merge" title="Merge nodes" style="display:none;"><span class="glyphicon glyphicon-resize-small" value="Merge nodes" ></span></button>
  </div>
  <div style="margin-left:13px;">
    <input type="text" id="search" style="width:157px;" title="Search" value="" placeholder="Search">
  </div>
  <div id="cyContainer">
  </div>

<div class="modal fade" id="default-modal" class="loginmodal" tabindex="-1" role="dialog" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="loginmodal-container">
      <span class="close-btn"><a href="javascript:void(0)" onclick="closeButton(this)">X</a></span>
      <h1 id="defaultModalTitle"></h1><br>
      <form id="defaultModalForm">
        <label for="defaultModalText" id="defaultModalLabel"></label>
        <input type="text" id="defaultModalText" value="">
        <div style="margin-top:20px;">
          <input type="submit" id="defaultModalButton" class="btn btn-success" value="Save">
        </div>
      </form>
    </div>
  </div>
</div>
<div class="modal fade" id="dimension-modal" class="loginmodal" tabindex="-1" role="dialog" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="loginmodal-container">
      <span class="close-btn"><a href="javascript:void(0)" onclick="closeButton(this)">X</a></span>
      <h1 id="dimensionModalTitle"></h1><br>
      <form id="dimensionModalForm">
        <label for="dimensionModalText" id="dimensionModalLabel"></label>
        <select id="dimensionModalSelect"></select>
        <div style="margin-top:20px;">
          <input type="submit" id="dimensionModalButton" class="btn btn-success" value="Save">
        </div>
      </form>
    </div>
  </div>
</div>
<div class="modal fade" id="multiselect-modal" class="loginmodal" tabindex="-1" role="dialog" aria-labelledby="movePageLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="loginmodal-container">
      <span class="close-btn"><a href="javascript:void(0)" onclick="closeButton(this)">X</a></span>
      <h1 id="multiselectTitle"></h1><br>
      <form id="multiselectForm">
        <div class="row">
            <div class="col-xs-5">
                <label for="multiselect"></label>
                <select name="from[]" id="multiselect" class="multiselect form-control" size="15" multiple="multiple"></select>
            </div>
            <div class="col-xs-2">
            <button type="button" id="multiselect_right_All_1" class="btn btn-block"><i class="glyphicon glyphicon-forward"></i></button>
            <button type="button" id="multiselect_right_Selected_1" class="btn btn-block"><i class="glyphicon glyphicon-chevron-right"></i></button>
            <button type="button" id="multiselect_left_Selected_1" class="btn btn-block"><i class="glyphicon glyphicon-chevron-left"></i></button>
            <button type="button" id="multiselect_left_All_1" class="btn btn-block"><i class="glyphicon glyphicon-backward"></i></button>
            </div>
            <div class="col-xs-5">
              <label for="multiselect_to"></label>
              <select name="to[]" id="multiselect_to" class="multiselect_to form-control" size="15" multiple="multiple"></select>
            </div>
        </div>
        <div style="margin-top:20px;">
          <input type="submit" id="submitMultiselect" class="btn btn-success" value="Save">
        </div>
    </form>
    </div>
  </div>
</div>
<script id="mainScript">
  const IS_STATIC = false;

  const STATIC_ARRAY = ['DIMENSIONS', 'MAJORATTRIBUTES', 'ATTRIBUTESPERDIMENSION', 'ATTRIBUTERELATIONS', 'INTERDIMENSIONALRELATIONS', 'RELATIONTYPES', 'CITATIONCOUNTS', 'CY'];

  const STATIC_INDEX_DIMENSIONS = 0;
  const STATIC_INDEX_MAJORATTRIBUTES = 1;
  const STATIC_INDEX_ATTRIBUTESPERDIMENSION = 2;
  const STATIC_INDEX_ATTRIBUTERELATIONS = 3;
  const STATIC_INDEX_INTERDIMENSIONALRELATIONS = 4;
  const STATIC_INDEX_RELATIONTYPES = 5;
  const STATIC_INDEX_CITATIONCOUNTS = 6;
  const STATIC_INDEX_CY = 7;

  var STATIC_DIMENSIONS;
  var STATIC_MAJORATTRIBUTES;
  var STATIC_ATTRIBUTESPERDIMENSION;
  var STATIC_ATTRIBUTERELATIONS;
  var STATIC_INTERDIMENSIONALRELATIONS;
  var STATIC_RELATIONTYPES;
  var STATIC_CITATIONCOUNTS;
  var STATIC_CY;
  var DYNAMIC_ARRAY = [];

  const DEFAULT_TAXONOMY_ID = 1;
  const DEFAULT_TAXONOMY_NAME = 'Integrity protection';
  var currentHash = '';
  var TAXONOMY_ID;

  const DEFAULT_DIMENSION_NAME = 'Interdimensional view';

  const ATTRIBUTE_URL = 'majorAttributes';
  const CITATION_COUNTS_URL = 'citationCountsIncludingChildren';

  const COLOR_BLUE = '#00008B';

  // cytoscape graph style options
  const STYLES = [
      {
        selector: '.child',
        style: {
          width: 'data(width)',
          height: '50px',
          color: 'black',
          'border-width': '2px',
          'border-style': 'solid',
          'border-color': 'grey',
          shape: 'rectangle',
          'background-color': 'white',
          label: 'data(id)',
          'text-valign': 'center',
          'text-halign': 'center',
          'overlay-opacity': 0
        }
      },
      {
        selector: '.parent',
        style: {
          width: 'data(width)',
          height: '50px',
          color: 'black',
          'border-width': '2px',
          'border-style': 'solid',
          'border-color': 'lightgrey',
          shape: 'roundrectangle',
          'background-color': 'white',
          label: 'data(id)',
          'text-valign': 'center',
          'text-halign': 'center',
          'overlay-opacity': 0
        }
      },
      {
        selector: '.dimension',
        style: {
          'background-color': 'white',
          'border-color': COLOR_BLUE,
          'color': COLOR_BLUE,
          'border-width': '1px',
          label: 'data(id)',
          'text-valign': 'top',
          'text-halign': 'right',
          'text-margin-x': '5px',
          'text-margin-y': '-5px',
          'compound-sizing-wrt-labels': 'include',
          'min-height-bias-top': '100%',
          'min-height-bias-bottom': '100%',
          'min-width-bias-left': '100%',
          'min-width-bias-right': '100%',
          'overlay-opacity': 0
        }
      },
      {
        selector: '.interdimensional',
        style: {
          'background-color': 'white',
          'border-color': COLOR_BLUE,
          'color': COLOR_BLUE,
          'border-width': '1px',
          label: 'data(id)',
          'text-valign': 'top',
          'text-halign': 'right',
          'text-margin-x': '5px',
          'text-margin-y': '-5px',
          'compound-sizing-wrt-labels': 'include',
          'min-height-bias-top': '100%',
          'min-height-bias-bottom': '100%',
          'min-width-bias-left': '100%',
          'min-width-bias-right': '100%',
          'overlay-opacity': 0
        }
      },
      {
        selector: 'edge',
        style: {
         'curve-style': 'segments',
         'segment-distances': '0px',
         'width': 1,
         'target-arrow-color': 'black',
         'line-color': 'black',
          label: 'data(annotation)',
          'text-margin-y': '-12px',
          'text-valign': 'center',
          'text-halign': 'center'
        }
      },
      {
        selector: '.Depends',
        style: {
          'target-arrow-shape': 'none',
          'target-arrow-fill': 'filled',
          'arrow-scale': 1
        }
      },
      {
        selector: '.DependsDirected',
        style: {
          'target-arrow-shape': 'triangle',
          'target-arrow-fill': 'filled',
          'arrow-scale': 1
        }
      },
      {
        selector: '.InstanceOf',
        style: {
          'target-arrow-shape': 'triangle',
          'target-arrow-fill': 'hollow',
          'arrow-scale': 2
        }
      },
      {
        selector: '.MemberOf',
        style: {
          'target-arrow-shape': 'diamond',
          'target-arrow-fill': 'hollow',
          'arrow-scale': 2.5
        }
      },
      {
        selector: '.PartOf',
        style: {
          'target-arrow-shape': 'diamond',
          'target-arrow-fill': 'filled',
          'arrow-scale': 2.5
        }
      }
    ];

  var cy;
  var isInterDimensional = true;
  var displayedDimension;

  var tappedBefore;
  var tappedTimeout;

  function handleErrorHelper ( error ) {
    if (!!cy) cy.elements().trigger('qtiphide');
    handleError(error);
  }

  // save node positions to the database
  function savePositions ( cy, dimensions ) {
    if (!admin) {
      handleErrorHelper('Requires edit permissions for this taxonomy.');
      return;
    }
    if (!displayedDimension) {
      handleErrorHelper('No dimension selected.');
      return;
    }
    var dimension = displayedDimension;
    if (displayedDimension == DEFAULT_DIMENSION_NAME) var saveURL = 'saveMajorPositions';
    else var saveURL = 'savePositions';
    var positions = [];
    cy.$('.parent,.child').forEach ( function ( node ) {
      var table = node.data('table');
      var position = node.position();
      positions.push({id: node.id(), table: table, x: '' + position.x, y: '' + position.y});
    });
    $.ajax
      ({
          type: "POST",
          url: saveURL,
          dataType: 'json',
          contentType:'application/json',
          async: true,
          data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, positions: positions, dimension: dimension}),
          success: function ( result ) {
            if (!result || !result.success) {
              handleErrorHelper('Cannot save positions.');
              return;
            }
            BootstrapDialog.show({
              title: 'Success',
              message: 'Saved positions successfully.'
            });
          }
      });
  }

  function traverseChildren ( cy, relations, parentID ) {
    relations.forEach ( function ( relation ) {
      if ((relation.relation == 'InstanceOf' || relation.relation == 'MemberOf' || relation.relation == 'PartOf') && relation.attributeDest == parentID) {
        var srcNode = cy.$('[id="' + relation.attributeSrc + '"]');
        if (srcNode.visible()) srcNode.style('display', 'none');
        else srcNode.style('display', 'element');
        traverseChildren(cy, relations, relation.attributeSrc);
      }
    });
  }

  // rename concept node
  function renameNode ( cy, ele ) {
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Enter new attribute name');
    $('#defaultModalLabel').html('Name:');
    $('#defaultModalText').val(ele.data('id'));
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var newAttributeName = $('#defaultModalText').val();
      if (newAttributeName == '' || cy.$('node[id="' + newAttributeName + '"]').length > 0) {
        handleErrorHelper('This attribute name already exists in this domain.');
        $('#defaultModalButton').prop('disabled', false);
        return;
      }
      var previousName = ele.data('id');
      var renameURL = (ele.data('table') == 'dimension') ? 'renameDimension' : 'renameAttribute';
      if (!admin) {
        $('#defaultModalButton').prop('disabled', false);
        $('#default-modal').modal('hide');
        cy.$('[id="' + previousName + '"]').data('id', newAttributeName);
      } else {
        $.ajax
          ({
              type: "POST",
              url: renameURL,
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, previousName: previousName, newName: newAttributeName}),
              success: function ( result ) {
                if (!result || !result.success) {
                  handleErrorHelper('Cannot rename attribute "' + previousName + '" to "' + newAttributeName + '". This name already exists.');
                  $('#defaultModalButton').prop('disabled', false);
                  return;
                }
                $('#defaultModalButton').prop('disabled', false);
                $('#default-modal').modal('hide');
                if (renameURL == 'renameDimension') {
                  loadTaxonomyData(TAXONOMY_ID, ATTRIBUTE_URL, CITATION_COUNTS_URL);
                } else window.location.reload(false);
              }
          });
        }
    });
    $('#default-modal').modal('show');
  }

  // change dimension of a concept node
  function changeDimension ( cy, ele ) {
    if (!DYNAMIC_ARRAY[STATIC_INDEX_DIMENSIONS]) {
      handleErrorHelper('Cannot find list of dimensions for this taxonomy.');
      return;
    }
    cy.elements().trigger('qtiphide');
    $('#dimensionModalTitle').html('Select new dimension');
    $('#dimensionModalLabel').html('Dimension:');
    $('#dimensionModalSelect').html('');
    DYNAMIC_ARRAY[STATIC_INDEX_DIMENSIONS].forEach ( function ( entry ) {
      $('#dimensionModalSelect').append('<option>' + entry.text + '</option>');
    });
    var attribute = ele.data('id');
    var previousDimension = ele.data('parent');
    $('#dimensionModalSelect').val(previousDimension);
    $('#dimensionModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#dimensionModalButton').prop('disabled', true);
      var dimension = $('#dimensionModalSelect').val();
      if (dimension == previousDimension || !dimension || dimension == '') {
        $('#dimensionModalButton').prop('disabled', false);
        $('#dimension-modal').modal('hide');
        return;
      }
      var dimensionObj = cy.$('.dimension[id="' + dimension + '"],.interdimensional[id="' + dimension + '"]');
      if (!admin) {
        $('#dimensionModalButton').prop('disabled', false);
        $('#dimension-modal').modal('hide');
        if (!!dimensionObj && dimensionObj.length > 0) cy.$('[id="' + attribute + '"]').move({parent: dimension});
        else cy.remove(cy.$('[id="' + attribute + '"]'));
      } else {
        $.ajax
          ({
            type: "POST",
            url: 'changeDimension',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attribute: attribute, dimension: dimension}),
            success: function ( result ) {
              if (!result || !result.success) {
                handleErrorHelper('Cannot change dimension for attribute "' + attribute + '".');
                $('#dimensionModalButton').prop('disabled', false);
                return;
              }
              $('#dimensionModalButton').prop('disabled', false);
              $('#dimension-modal').modal('hide');
              if (!!dimensionObj && dimensionObj.length > 0) cy.$('[id="' + attribute + '"]').move({parent: dimension});
              else cy.remove(cy.$('[id="' + attribute + '"]'));
            }
          });
        }
    });
    $('#dimension-modal').modal('show');
  }

  // change the "major" attribute of a node
  function switchMajor ( ele, dimension ) {
    var text = ele.id();
    var isMajor = ele.data('major') - 0;
    if (isNaN(isMajor)) {
      handleErrorHelper('Cannot read major attribute of "' + text + '".');
      return;
    }
    if (dimension == DEFAULT_DIMENSION_NAME) {
      handleErrorHelper('Cannot switch to/from major on the "' + DEFAULT_DIMENSION_NAME + '".');
      return;
    }
    function callback () {
      ele.classes((isMajor == 1) ? 'child' : 'parent');
      console.log('Switched the "major" property for attribute: "' + text + '".');
    }
    if (!admin) callback();
    else {
      $.ajax
        ({
          type: "POST",
          url: 'updateMajor',
          dataType: 'json',
          contentType:'application/json',
          async: true,
          data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, text: text, major: (isMajor == 1) ? 0 : 1}),
          success: function ( result ) {
            if (!result || !result.success) {
              handleErrorHelper('Error occurred while updating the major attribute of "' + text + '".');
              return;
            }
            callback();
          }
      });
    }
  }

  function testPerformanceAddNode ( nodeName, count, results, timeoutFactor, callback ) {
    if (count <= 0) {
      callback(results);
      return;
    }
    if (!results) results = [];
    var request = {'taxonomy_id': TAXONOMY_ID};
    request.x = '';
    request.y = '';
    request.xMajor = '';
    request.yMajor = '';
    request.major = 0;
    request.dimension = 'Attack view';
    var attributeName = 'Test' + nodeName;
    request.text = attributeName + '_' + count;
    var startTime = window.performance.now();
    $.ajax
      ({
          type: "POST",
          url: 'addAttribute',
          dataType: 'json',
          contentType:'application/json',
          async: true,
          data: JSON.stringify(request),
          success: function ( result ) {
            if (!result || !result.success) {
              handleErrorHelper('Error occurred while adding node.');
              return;
            }
            var endTime = window.performance.now();
            results.push(endTime - startTime);
            if (count <= 1) callback(results);
            else {
              setTimeout(function () {
                testPerformanceAddNode(nodeName, count-1, results, timeoutFactor, callback);
              }, timeoutFactor);
            }
          }
      });
  }

  function testPerformanceRemoveNode ( nodeName, count, results, timeoutFactor, callback ) {
    if (count <= 0) {
      callback(results);
      return;
    }
    if (!results) results = [];
    var request = {'taxonomy_id': TAXONOMY_ID};
    var attributeName = 'Test' + nodeName;
    request.text = attributeName + '_' + count;
    var startTime = window.performance.now();
    $.ajax
      ({
          type: "POST",
          url: 'removeAttribute',
          dataType: 'json',
          contentType:'application/json',
          async: true,
          data: JSON.stringify(request),
          success: function ( result ) {
            if (!result || !result.success) {
              handleErrorHelper('Error occurred while adding node.');
              return;
            }
            var endTime = window.performance.now();
            results.push(endTime - startTime);
            if (count <= 1) callback(results);
            else {
              setTimeout(function () {
                testPerformanceRemoveNode(nodeName, count-1, results, timeoutFactor, callback);
              }, timeoutFactor);
            }
          }
      });
  }

  function testPerformance ( funct, nodeName, count, timeoutFactor ) {
    funct(nodeName, count, [], timeoutFactor, function ( results ) {
      if (!results || results.length == 0) {
        handleErrorHelper("Cannot calculate average performance.");
        return;
      }
      results.sort( function ( a, b ) {
        return a < b ? -1 : (a == b ? 0 : 1);
      });
      var lengthIsOdd = results.length % 2 == 1;
      var median = 0;
      var index = Math.floor(results.length / 2);
      if (lengthIsOdd) median = results[index];
      else median = (results[index-1] + results[index]) / 2;
      var mean = 0;
      var standardDeviation = 0;
      for ( var i = 0; i < results.length; i++ ) {
        mean += results[i];
        standardDeviation += Math.pow(results[i] - median, 2);
      }
      mean /= results.length;
      standardDeviation = Math.sqrt(standardDeviation / results.length);
      console.log("median: " + median + ", mean: " + mean + ", deviation: " + standardDeviation);
    });
  }

  // add concept node
  function addNode ( cy, ele, e, major ) {
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Enter attribute name');
    $('#defaultModalLabel').html('Name:');
    $('#defaultModalText').val('');
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      console.time('AddNode');
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var attributeName = $('#defaultModalText').val();
      if (attributeName == '' || cy.$('[id="' + attributeName + '"]').length > 0) {
        handleErrorHelper('This attribute name already exists in this domain.');
        $('#defaultModalButton').prop('disabled', false);
        console.timeEnd('AddNode');
        return;
      }
      var request = {'taxonomy_id': TAXONOMY_ID, text: attributeName};
      if (isInterDimensional) {
        request.xMajor = '' + e.position.x;
        request.yMajor = '' + e.position.y;
        request.x = '';
        request.y = '';
      } else {
        request.x = '' + e.position.x;
        request.y = '' + e.position.y;
        request.xMajor = '';
        request.yMajor = '';
      }
      request.major = !!major ? 1 : 0;
      request.dimension = ele.id();
      function callback () {
        cy.add({ data: { id: attributeName, table: 'attribute', citationCount: 0, parent: ele.id(), width: attributeName.length * 10, major: (!!major ? 1 : 0) }, classes: (!!major ? 'parent' : 'child'), position: e.position });
        cy.$('[id="' + attributeName + '"]').qtip(getQtipOptions(attributeName));
        $('#defaultModalButton').prop('disabled', false);
        $('#default-modal').modal('hide');
      }
      if (!admin) {
        callback();
        return;
      }
      // if (admin) {
        $.ajax
          ({
              type: "POST",
              url: 'addAttribute',
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify(request),
              success: function ( result ) {
                console.timeEnd('AddNode');
                if (!result || !result.success) {
                  handleErrorHelper('This name already exists in the taxonomy. Please choose a different one or delete the other node.');
                  $('#defaultModalButton').prop('disabled', false);
                  return;
                }
                callback();
              }
          });
        // }
    });
    $('#default-modal').modal('show');
  }

  // add dimension compound node
  function addDimension ( cy, ele, e, major ) {
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Enter dimension name');
    $('#defaultModalLabel').html('Name:');
    $('#defaultModalText').val('');
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var dimensionName = $('#defaultModalText').val();
      if (!!dimensionName && dimensionName.split(' view').length <= 1) dimensionName += ' view';
      if (dimensionName == '' || cy.$('[id="' + dimensionName + '"]').length > 0) {
        handleErrorHelper('This dimension name already exists in this domain.');
        $('#defaultModalButton').prop('disabled', false);
        return;
      }
      var request = {'taxonomy_id': TAXONOMY_ID, text: dimensionName};
      function callback () {
        var position = ele.position();
        DYNAMIC_ARRAY[STATIC_INDEX_DIMENSIONS].push(dimensionName);
        cy.add({data: { id: dimensionName, table: 'dimension', parent: DEFAULT_DIMENSION_NAME }, classes: 'dimension', position: {x: position.x + ele.width(), y: position.y + ele.height()} });
        $('#defaultModalButton').prop('disabled', false);
        $('#default-modal').modal('hide');
      }
      if (!admin) callback();
      else {
        $.ajax
          ({
              type: "POST",
              url: 'addDimension',
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify(request),
              success: function ( result ) {
                if (!result || !result.success) {
                  handleErrorHelper('This name already exists in the taxonomy. Please choose a different one or delete the other dimension.');
                  $('#defaultModalButton').prop('disabled', false);
                  return;
                }
                callback();
              }
          });
        }
    });
    $('#default-modal').modal('show');
  }

  // remove concept nodes
  function removeNodes ( cy, selecteds ) {
    console.time('RemoveNodes');
    var promises = [];
    selecteds = selecteds.filter( function ( entry ) { return entry.data('table') == 'attribute' || entry.data('table') == 'dimension'; });
    selecteds.forEach ( function ( selected ) {
      var removePromise = new Promise ( function ( resolve, reject ) {
        var selectedID = selected.id();
        var selectedTable = selected.data('table');
        var removeURL = (selectedTable == 'dimension') ? 'removeDimension' : 'removeAttribute';
        if (!admin) resolve();
        else {
          $.ajax
            ({
              type: "POST",
              url: removeURL,
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, text: selectedID}),
              success: function ( result ) {
                console.timeEnd('RemoveNodes');
                if (!result || !result.success) {
                  if (selectedTable == 'dimension') handleErrorHelper('Error occurred while deleting dimension: "' + selectedID + '". Dimensions must be empty before they can be deleted.');
                  else handleErrorHelper('Error occurred while deleting node: "' + selectedID + '".');
                  return;
                }
                resolve();
              }
            });
          }
      });
      promises.push(removePromise);
    });
    Promise.all(promises)
      .then ( function ( results ) {
        console.log('Removed ' + results.length + ' attribute' + (results.length > 1 ? 's' : '') + ' successfully.');
        selecteds.forEach ( function ( selected ) {
          if (selected.data('table') == 'dimension' && !!DYNAMIC_ARRAY[STATIC_INDEX_DIMENSIONS]) {
            for ( var i = 0; i < DYNAMIC_ARRAY[STATIC_INDEX_DIMENSIONS].length; i++ ) {
              var dimensionEntry = DYNAMIC_ARRAY[STATIC_INDEX_DIMENSIONS][i];
              if (dimensionEntry.text == selected.id()) DYNAMIC_ARRAY[STATIC_INDEX_DIMENSIONS].unshift(dimensionEntry);
            }
          } else if (selected.data('table') == 'attribute') {
            var api = selected.qtip('api');
            api.destroy();
            api.disable();
          }
          cy.remove(selected);
        })
      }).catch ( function ( err ) {
        handleErrorHelper(err);
      });
  }

  // merge 2 nodes into 1 node
  function mergeNodes ( nodes ) {
    if (!admin) {
      handleErrorHelper('Requires edit permissions for this taxonomy.');
      return;
    }
    if (nodes.length != 2) {
      handleErrorHelper('Can only merge 2 attributes at a time.');
      return;
    }
    var text1 = nodes[0].data('id');
    var text2 = nodes[1].data('id');
    var dimension1 = nodes[0].data('parent');
    var dimension2 = nodes[1].data('parent');
    $.ajax
      ({
          type: "POST",
          url: 'mergeAttributes',
          dataType: 'json',
          contentType:'application/json',
          async: true,
          data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, text1: text1, text2: text2, dimension1: dimension1, dimension2: dimension2}),
          success: function ( result ) {
            if (!result || !result.success) {
              handleErrorHelper('Error occurred while merging the attributes "' + text1 + '" and "' + text2 + '". Make sure that a node with the name "' + text1 + ':' + text2 + '" does not exist.');
              return;
            }
            window.location.reload(false);
          }
      });
  }

  // load multiselect modal
  function loadMultiselect ( data, title, callback ) {
    $('#multiselectTitle').html(title);
    $('label[for="multiselect"]').html('Source node');
    $('label[for="multiselect_to"]').html('Target node');
    $('#multiselect, #multiselect_to').html('');
    data.forEach ( function ( entry ) {
      var text = !!entry.text ? entry.text : (!!entry.citation ? entry.citation : '');
      var id = !!entry.id ? entry.id : text;
      if (text != '') $('#multiselect').append('<option value="' + id + '" data_relation="' + (!!entry.relation ? entry.relation : '') + '">' + text + '</option>');
    });
    $('#multiselectForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      console.log('done');
      var options = [];
      $('#multiselect_to option').each ( function ( index, entry ) {
        var element = {id: entry.value};
        var relation = $(entry).attr('data_relation');
        if (!!relation && relation !='') element.relation = relation;
        options.push(element);
      });
      callback(options);
    });
  }

  // load modal used for the update of mappings between papers and concepts
  function loadCitationMappingMultiselect ( currentCitations, allCitations, title, callback ) {
    $('#multiselectTitle').html(title);
    $('label[for="multiselect"]').html('All citations');
    $('label[for="multiselect_to"]').html('Current citations');
    $('#multiselect, #multiselect_to').html('');
    var currentCitationTexts = [];
    currentCitations.forEach ( function ( entry ) {
      var text = entry.citation;
      var id = entry.id;
      if (text != '') {
        $('#multiselect_to').append('<option value="' + id + '">' + text + '</option>');
        currentCitationTexts.push(text);
      }
    });
    allCitations.forEach ( function ( entry ) {
      var text = entry.citation;
      var id = !!entry.id ? entry.id : text;
      if (text != '' && currentCitationTexts.indexOf(text) < 0) {
        $('#multiselect').append('<option value="' + id + '">' + text + '</option>');
      }
    });
    $('#multiselectForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      console.log('done');
      var options = [];
      $('#multiselect_to option').each ( function ( index, entry ) {
        var id = entry.value - 0;
        if (!isNaN(id)) options.push({id: id});
      });
      $('#multiselect-modal').modal('hide');
      callback(options);
    });
    if (!!cy) cy.elements().trigger('qtiphide');
    $('#multiselect-modal').modal('show');
  }

  // helper function for forking of nodes
  function chooseParentRelations ( data, callback ) {
    if (!!data && data.length > 0) {
      loadMultiselect(data, 'Parents of<br>first node', function ( resultTmp ) {
        loadMultiselect(data, 'Parents of<br>second node', function ( resultTmp2 ) {
          var result = [];
          var result2 = [];
          resultTmp.forEach ( function ( entry ) {
            result.push({text: entry.id, relation: entry.relation});
          });
          resultTmp2.forEach ( function ( entry ) {
            result2.push({text: entry.id, relation: entry.relation});
          });
          callback([result, result2]);
        });
      });
    } else callback([[],[]]);
  }

  // helper function for forking of nodes
  function chooseChildRelations ( data, callback ) {
    if (!!data && data.length > 0) {
      loadMultiselect(data, 'Children of<br>first node', function ( resultTmp ) {
        loadMultiselect(data, 'Children of<br>second node', function ( resultTmp2 ) {
          var result = [];
          var result2 = [];
          resultTmp.forEach ( function ( entry ) {
            result.push({text: entry.id, relation: entry.relation});
          });
          resultTmp2.forEach ( function ( entry ) {
            result2.push({text: entry.id, relation: entry.relation});
          });
          callback([result, result2]);
        });
      });
    } else callback([[],[]]);
  }

  // helper function for forking of nodes
  function chooseCitationMappings ( data, callback ) {
    if (!!data && data.length > 0) {
      loadMultiselect(data, 'Citations of<br>first node', function ( resultTmp ) {
        loadMultiselect(data, 'Citations of<br>second node', function ( resultTmp2 ) {
          var result = [];
          var result2 = [];
          resultTmp.forEach ( function ( entry ) {
            var idNumber = entry.id - 0;
            if (!isNaN(idNumber)) result.push({id: idNumber});
          });
          resultTmp2.forEach ( function ( entry ) {
            var idNumber = entry.id - 0;
            if (!isNaN(idNumber)) result2.push({id: idNumber});
          });
          callback([result, result2]);
        });
      });
    } else callback([[],[]]);
  }

  // update mappings between papers and a node
  function updateCitationMapping ( ele ) {
    if (!admin) {
      handleErrorHelper('Requires edit permissions for this taxonomy.');
      return;
    }
    var text = ele.data('id');
    $.ajax
      ({
        type: "POST",
        url: 'citation',
        dataType: 'json',
        contentType:'application/json',
        async: true,
        data: JSON.stringify({'taxonomy_id': TAXONOMY_ID}),
        success: function ( allCitations ) {
          if (!allCitations) {
            handleErrorHelper('Cannot get citations from DB.');
            return;
          }
          $.ajax
            ({
              type: "POST",
              url: 'citationsPerAttribute',
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attribute: text}),
              success: function ( citationsPerAttribute ) {
                if (!citationsPerAttribute) {
                  handleErrorHelper('Cannot get citations of attribute "' + text + '" from DB.');
                  return;
                }
                loadCitationMappingMultiselect(!!citationsPerAttribute.response ? citationsPerAttribute.response : [], !!allCitations.response ? allCitations.response : [], 'Citation mapping of "' + text + '"', function ( mappedCitations ) {
                  $.ajax
                    ({
                      type: "POST",
                      url: 'updateCitationMapping',
                      dataType: 'json',
                      contentType:'application/json',
                      async: true,
                      data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attribute: text, citations: mappedCitations}),
                      success: function ( result ) {
                        if (!result || !result.success) {
                          handleErrorHelper('Cannot update citation mapping of attribute: "' + text + '". Can only map papers to leaf nodes.');
                          return;
                        }
                        ele.data('citationCount', mappedCitations.length);
                        console.log('Updated citations mapping of attribute "' + text + '" successfully, mapped papers: ' + mappedCitations.length);
                      }
                  });
                });
              }
            });
        }
      });
  }

  // fork 1 node into 2
  function forkNode ( node ) {
    if (!admin) {
      handleErrorHelper('Requires edit permissions for this taxonomy.');
      return;
    }
    var text = node.data('id');
    var isMajor = node.data('major');
    var dimension = node.data('parent');
    $.ajax
      ({
          type: "POST",
          url: 'childRelationsPerAttribute',
          dataType: 'json',
          contentType:'application/json',
          async: true,
          data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, text: text, dimension: dimension}),
          success: function ( childRelations ) {
            if (!childRelations) {
              handleErrorHelper('Error occurred while forking the attribute: ' + text);
              return;
            }
            $.ajax
              ({
                  type: "POST",
                  url: 'parentRelationsPerAttribute',
                  dataType: 'json',
                  contentType:'application/json',
                  async: true,
                  data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, text: text, dimension: dimension}),
                  success: function ( parentRelations ) {
                    if (!parentRelations) {
                      handleErrorHelper('Error occurred while forking the attribute: ' + text);
                      return;
                    }
                    $.ajax
                      ({
                          type: "POST",
                          url: 'citationsPerAttribute',
                          dataType: 'json',
                          contentType:'application/json',
                          async: true,
                          data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attribute: text}),
                          success: function ( attributeCoverage ) {
                            if (!attributeCoverage) {
                              handleErrorHelper('Error occurred while forking the attribute: ' + text);
                              return;
                            }
                            if (!!parentRelations.response || childRelations.response || attributeCoverage.response) {
                              cy.elements().trigger('qtiphide');
                              if (!!cy) $('#multiselect-modal').modal('show');
                            }
                            chooseParentRelations(parentRelations.response, function ( parentResults ) {
                              chooseChildRelations(childRelations.response, function ( childResults ) {
                                chooseCitationMappings(attributeCoverage.response, function ( citationResults ) {
                                  $.ajax
                                    ({
                                        type: "POST",
                                        url: 'forkAttribute',
                                        dataType: 'json',
                                        contentType:'application/json',
                                        async: true,
                                        data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, text: text, dimension: dimension, parents1: parentResults[0], parents2: parentResults[1], children1: childResults[0], children2: childResults[1], citations1: citationResults[0], citations2: citationResults[1]}),
                                        success: function ( result ) {
                                          if (!result || !result.success) {
                                            handleErrorHelper('Cannot fork attribute "' + text + '".');
                                            return;
                                          }
                                          $('#multiselect-modal').modal('hide');
                                          window.location.reload(false);
                                        }
                                    });
                                });
                              });
                            });
                          }
                        });
                  }
            });
          }
      });
  }

  function removeItem ( cy, selecteds, callback ) {
    var selected = selecteds[0];
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Remove item');
    $('#defaultModalLabel').html('Type the name of the item to delete it:');
    $('#defaultModalText').val('');
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var deleteConfirmation = $('#defaultModalText').val().toLowerCase().trim();
      var selectedID = selected.id().toLowerCase();
      if ((deleteConfirmation != selectedID.trim()) && (deleteConfirmation != selectedID.split(' view').shift().trim())) {
        handleErrorHelper('Type the name of the item to delete it.');
        $('#defaultModalButton').prop('disabled', false);
        return;
      }
      $('#defaultModalButton').prop('disabled', false);
      $('#default-modal').modal('hide');
      callback(cy, selecteds);
    });
    $('#default-modal').modal('show');
  }

  // update the annotation text of an edge
  function updateEdgeAnnotation ( cy, ele, sourceID, targetID, dimensions, isInterDimensional ) {
    cy.elements().trigger('qtiphide');
    $('#defaultModalTitle').html('Enter edge annotation');
    $('#defaultModalLabel').html('Annotation:');
    $('#defaultModalText').val(ele.data('annotation'));
    $('#defaultModalForm').unbind().on('submit', function ( evt ) {
      evt.preventDefault();
      $('#defaultModalButton').prop('disabled', true);
      var annotation = $('#defaultModalText').val();
      function callback () {
        console.log('Updated taxonomy relation annotation successfully, annotation: ' + annotation + ', source: ' + sourceID + ', target: ' + targetID + '.');
        ele.data('annotation', annotation);
        $('#defaultModalButton').prop('disabled', false);
        $('#default-modal').modal('hide');
      }
      if (!admin) callback();
      else {
        $.ajax
          ({
              type: "POST",
              url: 'updateTaxonomyRelationAnnotation',
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attributeSrc: sourceID, attributeDest: targetID, dimension: (isInterDimensional ? DEFAULT_DIMENSION_NAME : dimensions[0].text), text: annotation}),
              success: function ( result ) {
                if (!result || !result.success) {
                   handleErrorHelper('Cannot update edge annotation.');
                   $('#defaultModalButton').prop('disabled', false);
                   return;
                 }
                 callback();
              }
          });
        }
    });
    $('#default-modal').modal('show');
  }

  // remove edges
  function removeEdges ( cy, selecteds ) {
    console.time('RemoveEdges');
    var promises = [];
    selecteds.forEach ( function ( selected ) {
      var removePromise = new Promise ( function ( resolve, reject ) {
        if (!admin) resolve();
        else {
          $.ajax
            ({
              type: "POST",
              url: 'removeTaxonomyRelation',
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attributeSrc: selected.data('source'), attributeDest: selected.data('target'), dimension: selected.data('dimension'), text: selected.data('relation')}),
              success: function () {
                console.timeEnd('RemoveEdges');
                resolve();
              }
            });
          }
      });
      promises.push(removePromise);
    });
    Promise.all(promises)
      .then ( function ( results ) {
        console.log('Removed ' + results.length + ' taxonomy relation' + (results.length > 1 ? 's' : '') + ' successfully.');
        selecteds.forEach ( function ( selected ) {
          cy.remove(selected);
        });
      }).catch ( function ( err ) {
        handleErrorHelper(err);
      });
  }

  function getQtipOptions ( id ) {
    var titleText = '<span><label>Citations</label><input type="button" class="listCitations" value="List" name="' + id + '" style="margin-left:15px;"></span>';
    var qtipOptions = {
      content: {
        text: function ( event, api ) {
          return '' + this.data('citationCount');
        },
        title: {
          text: titleText,
          button: true
        }
      },
      position: {
          my: 'top center',
          at: 'bottom center',
          adjust: {
            cyViewport: true
          }
      },
      style: {
          classes: 'qtip-light',
          tip: {
              corner: true,
              width: 23,
              height: 12
          }
      },
      events: {
        render: function(event, api) {
          $('.listCitations').unbind().click( function () {
            event.preventDefault();
            var attribute = $(this).attr('name');
            if (!attribute) return;
            $.ajax
              ({
                  type: "POST",
                  url: 'citationsPerAttributeIncludingChildren',
                  dataType: 'json',
                  contentType:'application/json',
                  async: true,
                  data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attribute: attribute}),
                  success: function ( citationsPerAttribute ) {
                    if (!citationsPerAttribute) {
                      handleErrorHelper('Cannot get citations from DB for attribute: ' + attribute + '.');
                      return;
                    }
                    var citationTable = '<div style="max-height:500px;overflow-y:auto;"><table class="table table-striped"><thead><tr><th>Citation</th><th>Occurrences</th><th>References</th><th>Bib</th></tr></thead><tbody>';
                    var sumOfReferences = 0;
                    if (!!citationsPerAttribute.response) {
                      citationsPerAttribute.response.forEach ( function ( citationPerAttribute ) {
                        citationTable += '<tr><td>' + citationPerAttribute.citation + '</td><td>' + citationPerAttribute.occurrenceCount + '</td><td>' + citationPerAttribute.referenceCount + '</td><td>' + citationPerAttribute.bib + '</td></tr>';
                        sumOfReferences += citationPerAttribute.referenceCount;
                      });
                    }
                    citationTable += '</tbody></table></div>';
                    if (sumOfReferences > 0) citationTable = '<div><p><b>Sum of references:</b>  ' + sumOfReferences + '</p></div>' + citationTable;
                    cy.elements().trigger('qtiphide');
                    BootstrapDialog.show({
                      title: 'Citations for attribute "' + attribute + '"',
                      message: citationTable
                    });
                  }
              });
          });
        }
      },
      show: {
        solo: true,
        event: 'qtipshow',
        cyBgOnly: true
      },
      hide: {
        event: 'qtiphide',
        cyViewport: true,
        cyBgOnly: true
      }
    };
    return qtipOptions;
  }

  // build JSON array, that is used to build the cytoscape graph
  function createJSON ( useCY, dimensions, interDimensional, attributes, relations, relationTypes, citationCounts ) {
    var items = [];
    var menuItems = [];
    isInterDimensional = interDimensional;
    var interDimensionalPosition = {x: $(window).width() / 2, y: $(window).height() / 2};
    if (!useCY) {
      dimensions.forEach ( function ( dimension ) {
        if (dimension.text == DEFAULT_DIMENSION_NAME) {
          var classText = 'interdimensional';
          var position = interDimensionalPosition;
        } else var classText = 'dimension';
        if (!!position) {
          if (isInterDimensional) items.push({data: { id: dimension.text, table: 'dimension', parent: DEFAULT_DIMENSION_NAME }, classes: classText, position: position});
          else items.push({data: { id: dimension.text, table: 'dimension' }, classes: classText, position: position }); // , style: { events: 'no' }
        } else {
          if (isInterDimensional) items.push({data: { id: dimension.text, table: 'dimension', parent: DEFAULT_DIMENSION_NAME }, classes: classText});
          else items.push({data: { id: dimension.text, table: 'dimension' }, classes: classText }); // , style: { events: 'no' }
        }
      });
      attributes.forEach ( function ( attribute ) {
        var x = attribute.x - 0;
        var y = attribute.y - 0;
        if (!isNaN(x) && !isNaN(y)) {
          var found = false;
          for ( var i = 0; i < citationCounts.length; i++ ) {
            if (citationCounts[i].attribute == attribute.text) {
              items.push({ data: { id: attribute.text, table: 'attribute', major: attribute.major, citationCount: citationCounts[i].citationCount, parent: attribute.dimension, width: attribute.text.length * 10 }, classes: (attribute.major == 1) ? 'parent' : 'child', position: {x: (attribute.x - 0), y: (attribute.y - 0)} });
              found = true;
              break;
            }
          }
          if (!found) {
            items.push({ data: { id: attribute.text, table: 'attribute', major: attribute.major, citationCount: 0, parent: attribute.dimension, width: attribute.text.length * 10 }, classes: (attribute.major == 1) ? 'parent' : 'child', position: {x: (attribute.x - 0), y: (attribute.y - 0)} });
          }
        }
      });
      relations.forEach ( function ( relation ) {
        var relationObj = { data: { id: relation.attributeSrc + '_' + relation.attributeDest, source: relation.attributeSrc, target: relation.attributeDest, annotation: !!relation.annotation ? relation.annotation : '', dimension: (isInterDimensional ? DEFAULT_DIMENSION_NAME : dimensions[0].text), relation: relation.relation }, classes: relation.relation };
        var points = [];
        if (!!relation.edgeBendPoints) {
          var edgeBendPoints = relation.edgeBendPoints != '' ? relation.edgeBendPoints.split(';') : [];
          try {
            edgeBendPoints.forEach ( function ( edgeBendPoint ) {
              points.push(JSON.parse(edgeBendPoint.replace(/\'/g, '"')));
            });
          } catch ( err ) {
            console.log('JSON parse error of edge bend points: ', relation.edgeBendPoints);
          }
        }
        relationObj.data.bendPointPositions = points;
        items.push(relationObj);
      });
    }

    // build cytoscape graph

    var options = {
        menuItems: menuItems,
        menuItemClasses: [
        ],
        contextMenuClasses: [
        ]
    };
    var cxtmenus = [];
    $('#cyContainer').html('<div id="cy" style="margin-top:50px;"></div>');
    cy = cytoscape({
      container: document.getElementById('cy'),
      elements: items,
      layout: {
        name: 'preset',
        zoom: 1,
        pan: {x: !!isInterDimensional ? ($(window).width() - 300) : 0, y: !!isInterDimensional ? $(window).height() + 200 : 0}
      },
      style: STYLES
    });
    cy.center(); // centers the view on all elements in the graph
    if (!!useCY) cy.json(DYNAMIC_ARRAY[STATIC_ARRAY.indexOf('CY')]);
    var edgeBendEditingApi = cy.edgeBendEditing({ initBendPointsAutomatically: true });

    // node commands
    var nodeCommands = [];
    nodeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Remove',
      select: function(ele){
        removeItem(cy, [ele], removeNodes);
      },
      enabled: true
    });
    nodeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Rename',
      select: function(ele){
        renameNode(cy, ele);
      },
      enabled: true
    });
    nodeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Change Dimension',
      select: function(ele){
        changeDimension(cy, ele);
      },
      enabled: true
    });
    if (!isInterDimensional) {
      nodeCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)',
        content: 'Switch major',
        select: function(ele){
          switchMajor(ele);
        },
        enabled: true
      });
    }
    nodeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Fork',
      select: function(ele){
        forkNode(ele);
      },
      enabled: true
    });
    nodeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Mapped papers',
      select: function(ele){
        updateCitationMapping(ele);
      },
      enabled: true
    });
    cxtmenus.push(cy.cxtmenu({
      menuRadius: 100,
      selector: '.parent,.child',
      commands: nodeCommands,
      fillColor: 'rgba(0, 0, 0, 0.75)',
      activeFillColor: 'rgba(92, 194, 237, 0.75)',
      activePadding: 20,
      indicatorSize: 24,
      separatorWidth: 3,
      spotlightPadding: 4,
      minSpotlightRadius: 24,
      maxSpotlightRadius: 38,
      openMenuEvents: 'cxttapstart',
      itemColor: 'white',
      itemTextShadowColor: 'black',
      zIndex: 9999,
      atMouse: false
    }));
    var edgeCommands = [];
    edgeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Remove',
      select: function(ele){
        removeEdges(cy, [ele]);
      },
      enabled: true
    });
    edgeCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Annotation',
      title: 'Annotation',
      select: function(ele){
        var sourceID = ele.data('source');
        var targetID = ele.data('target');
        updateEdgeAnnotation(cy, ele, sourceID, targetID, dimensions, isInterDimensional);
      },
      enabled: true
    });
    relationTypes.forEach ( function ( relationType ) {
      edgeCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)',
        content: relationType.text,
        title: relationType.comment,
        select: function(ele){
          var relation = ele.data('relation');
          if (relation == relationType.text) return;
          var sourceID = ele.data('source');
          var targetID = ele.data('target');
          function callback () {
            console.log('Updated taxonomy relation type successfully, type: ' + relationType.text + ', source: ' + sourceID + ', target: ' + targetID + '.');
            ele.classes(relationType.text);
            ele.data('relation', relationType.text);
            edgeBendEditingApi.initBendPoints(ele);
          }
          if (isInterDimensional && relationType.text != 'Depends' && relationType.text != 'DependsDirected') {
            handleErrorHelper('On the interdimensional view, only relations of the type "Depends" and "DependsDirected" are allowed.');
            return;
          }
          if (!admin) callback();
          else {
            $.ajax
              ({
                  type: "POST",
                  url: 'updateTaxonomyRelationType',
                  dataType: 'json',
                  contentType:'application/json',
                  async: true,
                  data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attributeSrc: sourceID, attributeDest: targetID, dimension: (isInterDimensional ? DEFAULT_DIMENSION_NAME : dimensions[0].text), text: relationType.text}),
                  success: function ( result ) {
                    if (!result || !result.success) {
                      handleErrorHelper('Cannot update the type of this taxonomy relation to the specified type. Circles in the hierarchical structure of a taxonomy and relations, that would result in a duplicate "parent-child" relationship, are not allowed.');
                      return;
                    }
                    callback();
                  }
              });
            }
        },
        enabled: true
      });
    });
    cxtmenus.push(cy.cxtmenu({
      menuRadius: 100,
      selector: 'edge',
      commands: edgeCommands,
      fillColor: 'rgba(0, 0, 0, 0.75)',
      activeFillColor: 'rgba(92, 194, 237, 0.75)',
      activePadding: 20,
      indicatorSize: 24,
      separatorWidth: 3,
      spotlightPadding: 4,
      minSpotlightRadius: 24,
      maxSpotlightRadius: 38,
      openMenuEvents: 'cxttapstart',
      itemColor: 'white',
      itemTextShadowColor: 'black',
      zIndex: 9999,
      atMouse: false
    }));
    var dimensionCommands = [];
    dimensionCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Remove',
      select: function(ele){
        removeItem(cy, [ele], removeNodes);
      },
      enabled: true
    });
    dimensionCommands.push({
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Rename',
      select: function(ele){
        renameNode(cy, ele);
      },
      enabled: true
    });
    if (!isInterDimensional) {
      dimensionCommands.push({
        fillColor: 'rgba(200, 200, 200, 0.75)',
        content: 'Add node',
        title: 'Add node',
        select: function(ele, e){
          e.preventDefault();
          addNode(cy, ele, e, false);
        },
        enabled: true
      });
    }
    var addMajorNodeCommand = {
      fillColor: 'rgba(200, 200, 200, 0.75)',
      content: 'Add major node',
      title: 'Add major node',
      select: function(ele, e){
        e.preventDefault();
        addNode(cy, ele, e, true);
      },
      enabled: true
    };
    dimensionCommands.push(addMajorNodeCommand);
    if (isInterDimensional) {
      var addDimensionCommand = {
        fillColor: 'rgba(200, 200, 200, 0.75)',
        content: 'Add dimension',
        title: 'Add dimension',
        select: function(ele, e){
          e.preventDefault();
          addDimension(cy, ele, e, true);
        },
        enabled: true
      };
      dimensionCommands.push(addDimensionCommand);
      var interdimensionalCommands = [];
      interdimensionalCommands.push(addMajorNodeCommand);
      interdimensionalCommands.push(addDimensionCommand);
      cxtmenus.push(cy.cxtmenu({
        menuRadius: 100,
        selector: '.interdimensional',
        commands: interdimensionalCommands,
        fillColor: 'rgba(0, 0, 0, 0.75)',
        activeFillColor: 'rgba(92, 194, 237, 0.75)',
        activePadding: 20,
        indicatorSize: 24,
        separatorWidth: 3,
        spotlightPadding: 4,
        minSpotlightRadius: 24,
        maxSpotlightRadius: 38,
        openMenuEvents: 'cxttapstart',
        itemColor: 'white',
        itemTextShadowColor: 'black',
        zIndex: 9999,
        atMouse: true
      }));
    }
    cxtmenus.push(cy.cxtmenu({
      menuRadius: 100,
      selector: '.dimension',
      commands: dimensionCommands,
      fillColor: 'rgba(0, 0, 0, 0.75)',
      activeFillColor: 'rgba(92, 194, 237, 0.75)',
      activePadding: 20,
      indicatorSize: 24,
      separatorWidth: 3,
      spotlightPadding: 4,
      minSpotlightRadius: 24,
      maxSpotlightRadius: 38,
      openMenuEvents: 'cxttapstart',
      itemColor: 'white',
      itemTextShadowColor: 'black',
      zIndex: 9999,
      atMouse: true
    }));
    var ur = cy.undoRedo();
    $(document).off("keydown").on("keydown", function (e) {
      if(e.which === 46) { // delete
          var selecteds = cy.$(':selected');
          if (selecteds.length == 0) return;
          if (selecteds.length > 1) {
            handleErrorHelper('Can only remove one item at a time');
            return;
          }
          var selecteds = cy.$("node:selected");
          if (selecteds.length > 0) {
            removeItem(cy, selecteds, removeNodes);$()
            return;
          }
          selecteds = cy.$("edge:selected");
          if (selecteds.length > 0) {
            removeEdges(cy, selecteds);
          }
        }
        else if (e.ctrlKey && e.target.nodeName === 'BODY')
            if (e.which === 90)
                ur.undo();
            else if (e.which === 89)
                ur.redo();
    });
    cy.$('.parent,.child').each ( function ( entry, index ) {
      entry.qtip(getQtipOptions(entry.data('id')));
    });

    // initialize cytoscape extensions

    cy.panzoom();
    cy.edgehandles({handleNodes: '.child, .parent'});
    var viewUtilities = cy.viewUtilities({
      node: {
        highlighted: { 'color': COLOR_BLUE, 'border-color': COLOR_BLUE },
        unhighlighted: { 'opacity': 1 }
      },
      edge: {
        highlighted: { 'color': COLOR_BLUE, 'line-color': COLOR_BLUE },
        unhighlighted: { 'opacity': 1 }
      }
    });
    cy.on('select', '.parent,.child', function ( evt ) {
      var node = evt.target;
      node.trigger('qtipshow');
      var selecteds = cy.$('.parent:selected, .child:selected');
      if (selecteds.length > 2) {
        selecteds.each ( function ( selected ) {
          if (selected.data('id') != node.data('id')) selected.unselect();
        });
      }
      viewUtilities.highlight(node);
    });
    cy.on('select', 'edge', function ( evt ) {
      var edge = evt.target;
      viewUtilities.highlight(edge);
    });
    cy.on('unselect', '.parent,.child', function ( evt ) {
      var node = evt.target;
      node.trigger('qtiphide');
      viewUtilities.unhighlight(node);
    });
    cy.on('unselect', 'edge', function ( evt ) {
      var edge = evt.target;
      viewUtilities.unhighlight(edge);
    });
    cy.on('ehcomplete', function (event, sourceNode, targetNode, addedEles) {
      var sourceID = sourceNode.id();
      var targetID = targetNode.id();
      addedEles.forEach ( function ( entry ) {
        entry.data('id', sourceID + '_' + targetID);
        console.log("id:", entry.data('id'))
      });
      function callback () {
        console.log('Added taxonomy relation successfully, source: ' + sourceID + ', target: ' + targetID + '.');
      }
      function failureCallback () {
        addedEles.forEach ( function ( entry ) {
          cy.remove(entry);
        });
      }
      if (!admin) callback();
      else {
        console.time('AddEdge');
        $.ajax
          ({
              type: "POST",
              url: 'addTaxonomyRelation',
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attributeSrc: sourceNode.id(), attributeDest: targetNode.id(), dimension: (isInterDimensional ? DEFAULT_DIMENSION_NAME : dimensions[0].text), text: 'Depends'}),
              success: function ( result ) {
                console.timeEnd('AddEdge');
                if (!result || !result.success) {
                  handleErrorHelper('Cannot add this taxonomy relation. Circles in the hierarchical structure of a taxonomy and relations, that would result in a duplicate "parent-child" relationship, are not allowed.');
                  failureCallback();
                  return;
                }
                callback();
              }
          });
        }
    });
    var expandCollapseApi = cy.expandCollapse({
      layoutBy: {
        name: "preset",
        animate: "end"
      },
      fisheye: false,
      animate: false,
      undoable: false,
      expandCollapseCuePosition: function ( e ) { var position = e.position(); return {x: position.x + e.width()/2 - 21, y: position.y - e.height()/2 - 5}; },
      expandCollapseCueSensitivity: 1.5,
      expandCollapseCueSize: 20,
      // base64 zoom icons (put straight into the file to be able to make the HTML file "static")
      expandCueImage: `data:image/png;base64,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`, //'zoomInIcon.png',
      collapseCueImage: `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAG50lEQVRYhb2WW2wcVxnHfzOzszO73vt6vetrHBLXdhzHhJe+AMIyeSBCqiIh8YaEeOQB9Qkh8dQ2BXFpVRClRUIgpUCF1NRBvSkESIsaKjcOudje2HFsx5d1vN71ej32rD07Fx5mHNvBt0iUI33ac86Ozvc733f+3zkCB7QXfvarXllRemtCkVZdX20VBEkol5f/advO1NCtwf6//PlCAbAPWmevJuw2+dxPfxkLBkPPptKZ78WTtdFQOIok+TAtG8Mw0HWd5VKJ+dws83Ozb06O333+vYt/GAMswHkSAOnxiRdf/vXpdKbh6onuzz/T1NKqgsBScYnlUpmKrqNpGuXlMoIoEY4liMSTJ2Ul8N1Mc6t19/b1T58UYgfAiy+/9u229q73nuo6FasaJtMP5qgJhGhuaqGxoZF0XZp0XT31mUYkQaBULLK0XCYYiRMIhnobmo92Zm8NfACYh4V4BPD6hbd6U+n6i0ePt7OQm0f1K3Sf6KIulSQUVAmoflS/n4AqE1BkYpEomfoGLBTuDI2SSMYIhWOdqXRTw+id638HqoeBkAB+eP6lWCKZ+uR4R5f6cC5HfV2a40ePIssSoiggCgKCgGsISKKILPtQ/DK18Si6E+He2CjJZAwlEOjxyf6RmYnR+x7Evk0EqAlFnq1vOhItLZXI1KZoPdLiOQZx07HgnlhxW98niYRqFE62NdPR9TSLi0WSqQzHOrp/AsQB/6EicO6b3+pPZRrVaqVC94kuLAf0DTA9cUnillME1zb7AgJ+2Y8jqeQLGo6poQaDIVGUZqcnRkeAjf1SIf7guZ+fiyVT0dJSkdbmZkQBJAFkCWwbKgaU9S0gQXDDtgkkCKDIAnXxMJ2dJ1kqrRIKR0k3tpwBwoBvvwj4fIp62udX0LUVMuk0ggCyCBPzBjgORtXGMB1My8a2HQQcVNlGwMF2bBzbof1YLYrfRyYVJxJNgWATi6dOAyEvDcaeAKZlf2XDMAmoiptz0c3zj9/IY5oGllnF2vy1DMztY9PAMg3eff0biAKEgwHC4Qgb64sEQ+E0EDgoAqJlO+iVdTbW1x85FwUO7dw0q1QtLxV+iUg0iWVZ+GQZz/l/FbsdAJVKRVjTdUzT3IqAyKGdW6bBuuECSKKAY1aQRAlZ9oGnsn3PwKq2+kDXK19UBRlJ3JLZ2z9q3/Gh47hmb+87UDVhadX1ZAtgWQahUA2OWTnItxuBtTXtjmFskC+WMU0DUXRlJ3lq2FELRE8BbCkAvP+9BStry4TCYbRy6Q6HuBfE5WKhf3WljC36GB7JulF43B4vSNuK0Xp1a5xfmEcULWSfxMLczDVgHfde2Bvgcv8b46VC/pos+/l48A5m1dhxFiRvcXG7/r0QmBZY9tbcvXvDZOrr0VdKjN4e+AhYYx8Jgpe64uL8+XKpgG6KXPrgb4iCs7VrcZfd456B7bsfHr6NINmoqsLE2NClfw8OTAKrHHAfSABjQzcetBzrbIjX1n0hv7SKVi7xuSONSJK088XiuAl1HNANd/eOA9m7d8ktzBBP1jJ8+0b+wm9eeX5VW5kFCgdFYFOj9vCNf/3jqc7uc9FEqnZuscz4/Qnq6+JEwmEQvJPPVnm2bSivaAxcH2BZWyYYijB59zZNTS01S7ozoVCZWVxcnOWA59r2ImFVKvo7iqq2RmKJjg3Hxyc3hhifmGRjYwPHEdBWdZaW1xifnGIoO0p2bJRoIkEsFuOvly8z87BId2cbIVX4krmufaenp6cwNDS0rxq2AziFhdza0OC1y+Foouz3K0/HEyk/coBcYYXs/VnGpuaYeZinUrUIhsIkkgn01RU+/fjDS+/3v3k+GG84FQ2pCb9ZZnBwkGAw+LXOzs5yNpu9xR6vpMfLpA0Y4yM3by7MTb9tWdW8Y9lSTU2gRVUVgsEgsixjVQ0W5mcnxoZufPj711554a0//e6d4uLDyT/+9hdr7Ucbvjo9PU0ul6NYLBIOh890dHSUs9nszd0gdn0V46pDwb3NwkCovb29rv3k6Y6V4sOFq1evznuLGbhSWwG0s2fPnmpqanq/r68vksvluHLlCuVymUwmg23b37948eKrgM62c7EXwHYQGfdKlT2TvAVMXIlVPRALkHp7e7/c1tbW39fXFz4MxL43lRcuy3NQ8WzNMx230lW37ciZmpqaDwaDA5qmPdPT06OkUql903EQwG5Am7ZXs6anp2f3glAU5UwymXRmZmYGAPNJAQ7b9oTI5/NUKpXAwsLCu0DlswLYFUKSJEZGRigUCq9qmnYP0D5LgEcQhmEMTExMfN1xnHI+n39pbGzsClAEVg5Swf+iCbiSTgK13njJA6j8PwA2IWRA9cYbeOr5D45SeXNpD8IlAAAAAElFTkSuQmCC`
    });
    cy.$('.interdimensional').on('expandcollapse.beforecollapse', function ( e ) {
      e.preventDefault();
      e.stopPropagation();
    });
    cy.$('.interdimensional').on('expandcollapse.beforeexpand', function ( e ) {
      e.preventDefault();
      e.stopPropagation();
    });
    function expandDimension ( node ) {
      cy.$('.parent,.child').each ( function ( node, index ) {
        var api = node.qtip('api');
        api.destroy();
        api.disable();
      });
      cxtmenus.forEach ( function ( cxtmenu ) {
        cxtmenu.destroy();
      });
      cy.destroy();
      if (isInterDimensional) var dimText = node.id();
      else var dimText = DEFAULT_DIMENSION_NAME;
      displayedDimension = dimText;
      var hash = window.location.hash;
      // prevent page reload on hash change
      if (hash.split('#').length > 1) currentHash = hash.split('_').shift() + '_' + dimText;
      else currentHash = '#' + DEFAULT_TAXONOMY_ID + '_' + dimText;
      window.location.hash = currentHash;
      //showDimension(dimText);
      loadTaxonomyData(TAXONOMY_ID, ATTRIBUTE_URL, CITATION_COUNTS_URL);
    }
    function collapseDimension () {
      displayedDimension = DEFAULT_DIMENSION_NAME;
      var hash = window.location.hash;
      // prevent page reload on hash change
      if (hash.split('#').length > 1) currentHash = hash.split('_').shift() + '_' + displayedDimension;
      else currentHash = '#' + DEFAULT_TAXONOMY_ID + '_' + displayedDimension;
      window.location.hash = currentHash;
    }
    cy.$('.dimension').on('expandcollapse.beforecollapse', function ( e ) {
      expandDimension(this);
    });
    cy.$('.dimension').on('expandcollapse.beforeexpand', function ( e ) {
      collapseDimension();
    });

    // Source: https://stackoverflow.com/questions/18610621/cytoscape-js-check-for-double-click-on-nodes
    cy.on('tap', '.dimension', function(event) {
      var tappedNow = event.cyTarget;
      if (tappedTimeout && tappedBefore) {
        clearTimeout(tappedTimeout);
      }
      if(tappedBefore === tappedNow) {
        this.trigger('doubleTap');
        tappedBefore = null;
      } else {
        tappedTimeout = setTimeout(function(){ tappedBefore = null; }, 300);
        tappedBefore = tappedNow;
      }
    });
    cy.on('doubleTap', '.dimension', function(event) {
      expandDimension(event.target);
    });

    $('#search').unbind().on('input', function () {
      var text = this.value;
      if (!!text && text.length > 1) {
        var foundNodes = cy.$('[id="' + text + '"]');
        viewUtilities.unhighlight(cy.$('[id!="' + text + '"]'));
        viewUtilities.highlight(foundNodes);
        if (!!foundNodes && foundNodes.length > 0) console.log('Found: ', foundNodes);
        else console.log('Did not find any nodes with that name.');
      }
    });
    $('#clickMe').unbind().click ( function () {
      savePositions(cy, dimensions);
    });
    // save edge bend points to the database
    $('#getEdges').unbind().click ( function () {
      if (!admin) {
        handleErrorHelper('Requires edit permissions for this taxonomy.');
        return;
      }
      if (!displayedDimension) {
        handleErrorHelper('No dimension selected.');
        return;
      }
      var dimension = displayedDimension;
      var promises = [];
      cy.edges().forEach ( function ( entry ) {
        var segments = entry.segmentPoints();
        if (!!segments) {
          var segmentStr = '';
          segments.forEach ( function ( segment ) {
            segmentStr += (segmentStr != '' ? ';' : '') + JSON.stringify(segment);
          });
          segmentStr = segmentStr.replace(/\"/g, "'");
          var attributeSrc = entry.data('source');
          var attributeDest = entry.data('target');
          var saveEdgeBendPointsPromise = new Promise ( function ( resolve, reject ) {
            $.ajax
              ({
                  type: "POST",
                  url: 'saveEdgeBendPoints',
                  dataType: 'json',
                  contentType:'application/json',
                  async: true,
                  data: JSON.stringify({'taxonomy_id': TAXONOMY_ID, attributeSrc: attributeSrc, attributeDest: attributeDest, edgeBendPoints: segmentStr, dimension: dimension}),
                  success: function ( result ) {
                    if (!result || !result.success) {
                      reject('Error occurred while saving edge bend points to DB.');
                      return;
                    }
                    resolve(result);
                  },
                  error: function () {
                    reject('Error occurred while saving edge bend points to DB.');
                  }
              });
            });
            promises.push(saveEdgeBendPointsPromise);
          }
      });
      if (promises.length == 0) {
        console.log('Saved edge bend points successfully.');
        savePositions(cy, dimensions);
        return;
      }
      Promise.all(promises)
        .then ( function ( results ) {
          console.log('Saved edge bend points successfully.');
          savePositions(cy, dimensions);
        }).catch ( function ( err ) {
          handleErrorHelper(err);
        });
    });
    $('#merge').unbind().click ( function () {
       var selecteds = cy.$(".parent:selected, .child:selected");
       if (selecteds.length < 2) {
         handleErrorHelper('Not enough attributes selected.');
         return;
       } else if (selecteds.length > 2) {
         handleErrorHelper('Can only merge 2 attributes at a time.');
         return;
       }
       mergeNodes(selecteds);
    });
    $('#multiselect-modal').on('shown.bs.modal', function () {
      console.log('shown')
      $('.multiselect').multiselect({
          rightAll: '#multiselect_right_All_1',
          right: '#multiselect_to',
          rightSelected: '#multiselect_right_Selected_1',
          leftSelected: '#multiselect_left_Selected_1',
          leftAll: '#multiselect_left_All_1',
          search: {
              left: '<input type="text" name="q" class="form-control" placeholder="Search..." />',
              right: '<input type="text" name="q" class="form-control" placeholder="Search..." />',
          },
          fireSearch: function(value) {
              return value.length > 0;
          }
      });
    });
    var qtipShown = false;
    $('#qtip').unbind().click ( function () {
      if (!qtipShown) {
        cy.elements().trigger('qtipshow');
        qtipShown = true;
      } else {
        cy.elements().trigger('qtiphide');
        qtipShown = false;
      }
    });
    $('#exportPNG').unbind().click ( function () {
      var pngFile = cy.png({full: true});
      var dataLink = document.createElement('a');
      dataLink.download = 'TaxonomyRelations.png';
      dataLink.href = pngFile;
      document.body.appendChild(dataLink);
      dataLink.click();
      document.body.removeChild(dataLink);
      delete dataLink;
    });
    $('#exportHTML').unbind().click ( function () {
      DYNAMIC_ARRAY[STATIC_ARRAY.indexOf('CY')] = cy.json();
      exportHTML('TaxonomyRelations.html');
    });
    $('#exportJSON').unbind().click ( function () {
      console.log("json: ", cy.json());
    });
  }

    function initPage () {
      if (!IS_STATIC) {
        var hash = window.location.hash.split('#').pop().split('_').shift();
        var hashInt = hash - 0;
        if (hashInt == 0 || isNaN(hashInt)) {
          $.ajax
            ({
              type: "POST",
              url: 'getTaxonomyID',
              dataType: 'json',
              contentType:'application/json',
              async: true,
              data: JSON.stringify({text: unescape(hash)}),
              success: function ( taxonomy ) {
                if (!taxonomy || !taxonomy.response || taxonomy.response.length == 0) {
                  TAXONOMY_ID = DEFAULT_TAXONOMY_ID;
                  currentHash = '#' + DEFAULT_TAXONOMY_NAME;
                  window.location.hash = currentHash;
                  //loadTaxonomyData(TAXONOMY_ID, ATTRIBUTE_URL, CITATION_COUNTS_URL);
                  return;
                } else {
                  var id = taxonomy.response[0].id - 0;
                  console.log("taxonomy id: ", id)
                  if (!isNaN(id)) TAXONOMY_ID = id;
                  else {
                    TAXONOMY_ID = DEFAULT_TAXONOMY_ID;
                    currentHash = '#' + DEFAULT_TAXONOMY_NAME;
                    window.location.hash = currentHash;
                  }
                }
                loadTaxonomyData(TAXONOMY_ID, ATTRIBUTE_URL, CITATION_COUNTS_URL);
              }, failure: function () {
                TAXONOMY_ID = DEFAULT_TAXONOMY_ID;
                //loadTaxonomyData(TAXONOMY_ID, ATTRIBUTE_URL, CITATION_COUNTS_URL);
                currentHash = '#' + DEFAULT_TAXONOMY_NAME;
                window.location.hash = currentHash;
              }
          });
        } else {
          TAXONOMY_ID = hashInt;
          loadTaxonomyData(TAXONOMY_ID, ATTRIBUTE_URL, CITATION_COUNTS_URL);
        }
      } else {
        TAXONOMY_ID = DEFAULT_TAXONOMY_ID;
        currentHash = '#' + DEFAULT_TAXONOMY_NAME;
        window.location.hash = currentHash;
        loadTaxonomyData(TAXONOMY_ID, ATTRIBUTE_URL, CITATION_COUNTS_URL);
      }
    }

    $(document).ready( function () {
      window.onhashchange = function () {
        var hash = window.location.hash;
        // prevent page reload when a compound node is being expanded or collapsed
        if (unescape(hash) != unescape(currentHash)) window.location.reload(false);
      };

      $(this).on('contextmenu', function ( e ) {
        e.preventDefault();
      });
      if (!!IS_STATIC) {
        loadBanner('STATIC');
        $('#getEdges, #merge').hide();
        initPage();
        return;
      }
      var initUserManagementPromise = new Promise ( function ( resolve, reject ) {
        initUserManagement(resolve, reject);
      }).then ( function ( user ) {
        if (!!user && user.admin == 1) {
          $('#getEdges').show();
          $('#merge').show();
        }
        initPage();
      }).catch ( function ( err ) {
        console.log('Error loading user: ', err);
        handleError(err);
        initPage();
      });
    });
	</script>
<!-- main script end -->
</body>
</html>
