<!doctype html>
<html>
<head>
    <title>Circle Packing</title>
    <script src="jquery.min.js"></script>
    <script type="text/javascript" src="d3.min.js"></script>
    <script type="text/javascript" src="d3-hierarchy.v1.min.js"></script>

    <link href="bootstrap.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap.min.js"></script>

    <link href="bootstrap-dialog.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap-dialog.min.js"></script>

    <script src="multiselect.min.js"></script>

    <link href="loginForm.css" type="text/css" rel="stylesheet"/>

    <!-- promises -->
    <script src="bluebird.min.js"></script>

    <link href="d3-context-menu.css" type="text/css" rel="stylesheet"/>
    <script src="d3-context-menu.js"></script>

    <link href="d3-tip.css" type="text/css" rel="stylesheet"/>
    <script src='d3-tip.js'></script>

    <script type="text/javascript" src="FileSaver.min.js"></script>

    <script src="error.js"></script>
    <style>

    .node {
      cursor: pointer;
    }

    .node:hover {
      stroke: #000;
      stroke-width: 1.5px;
    }

    .node--leaf {
      fill: white;
    }

    .label {
      font: 11px "Helvetica Neue", Helvetica, Arial, sans-serif;
      text-anchor: middle;
      text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff, 0 -1px 0 #fff;
    }

    .label,
    .node--root,
    .node--leaf {
      pointer-events: none;
    }

    </style>
</head>
<body>
  <div style="width:165px;margin-top:30px;margin-bottom:30px;margin-left:10px;">
    <form>
      <label for="dataType">Data Type: </label><select class="form-control" id="dataType">
        <option value="citationCount" selected="selected">Citation count</option>
        <option value="referenceCount">Sum of references</option>
      </select>
      <label for="colorTheme">Color Theme</label><select class="form-control" id="colorTheme"></select>
      <input type="button" class="btn btn-success" id="export" style="margin-top:15px;" value="Export">
  </form>
  </div>
  <div id="colorLegend" style="margin-left:330px;margin-top:30px;margin-bottom:15px;"></div>
  <div id="svgContainer">
  </div>
<script>

  const colorsBlue = ["#1CB5E0", "#189ECC", "#1587B9", "#1171A6", "#0E5A93", "#0A437F", "#072D6C", "#031659", "#000046"];
  const colorsYGB = ["#F0F8FF","#AAF191","#80D385","#61B385","#3E9583","#217681","#285285","#1F2D86","#000086"]; // #FFFFDD
  const colorsRainbow = ["#2c7bb6", "#00a6ca","#00ccbc","#90eb9d","#ffff8c","#f9d057","#f29e2e","#e76818","#d7191c"];
  const colorsWeddingDayBlues = ["#40E0D0", "#6FCB9C", "#9FB668", "#CFA134", "#FF8C00", "#FF6920", "#FF4640", "#FF2360", "FF0080"];
  const colors2 = ["#DFDFDF", "#BFBFBF", "#9F9F9F", "#7F7F7F", "#5F5F5F", "#3F3F3F", "#1F1F1F", "#000000"];
  const colors3 = ["#8078FA", "#7069E2", "#605ACA", "#514BB2", "#413C9A", "#312D82", "#221E6A", "#120F52", "#03003B"];
  const colors4 = ["#F0F2F0", "#D2D5DA", "#B4B8C4", "#969BAE", "#787F98", "#5A6282", "#3C456C", "#1E2856", "#000C40"];

  const COLOR_GRADIENTS =  [{name: 'blue', colors: colorsBlue}, {name: 'ygb', colors: colorsYGB}, {name: 'rainbow', colors: colorsRainbow}, {name: 'weddingDayBlues', colors: colorsWeddingDayBlues}, {name: 'colors2', colors: colors2}, {name: 'colors3', colors: colors3}, {name: 'colors4', colors: colors4}];

  var color = d3.scale.linear()
      .domain([-1, 5])
      .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
      .interpolate(d3.interpolateHcl);

  var isInterDimensional = true;
  var displayedDimension;

  function getSVGString( svgNode ) {
    svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
    var cssStyleText = getCSSStyles( svgNode );
    appendCSS( cssStyleText, svgNode );

    var serializer = new XMLSerializer();
    var svgString = serializer.serializeToString(svgNode);
    svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
    svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

    return svgString;

    function getCSSStyles( parentElement ) {
      var selectorTextArr = [];

      // Add Parent element Id and Classes to the list
      selectorTextArr.push( '#'+parentElement.id );
      for (var c = 0; c < parentElement.classList.length; c++)
          if ( !contains('.'+parentElement.classList[c], selectorTextArr) )
            selectorTextArr.push( '.'+parentElement.classList[c] );

      // Add Children element Ids and Classes to the list
      var nodes = parentElement.getElementsByTagName("*");
      for (var i = 0; i < nodes.length; i++) {
        var id = nodes[i].id;
        if ( !contains('#'+id, selectorTextArr) )
          selectorTextArr.push( '#'+id );

        var classes = nodes[i].classList;
        for (var c = 0; c < classes.length; c++)
          if ( !contains('.'+classes[c], selectorTextArr) )
            selectorTextArr.push( '.'+classes[c] );
      }

      // Extract CSS Rules
      var extractedCSSText = "";
      for (var i = 0; i < document.styleSheets.length; i++) {
        var s = document.styleSheets[i];
        
        try {
            if(!s.cssRules) continue;
        } catch( e ) {
              if(e.name !== 'SecurityError') throw e; // for Firefox
              continue;
            }

        var cssRules = s.cssRules;
        for (var r = 0; r < cssRules.length; r++) {
          if ( contains( cssRules[r].selectorText, selectorTextArr ) )
            extractedCSSText += cssRules[r].cssText;
        }
      }
      

      return extractedCSSText;

      function contains(str,arr) {
        return arr.indexOf( str ) === -1 ? false : true;
      }

    }

    function appendCSS( cssText, element ) {
      var styleElement = document.createElement("style");
      styleElement.setAttribute("type","text/css"); 
      styleElement.innerHTML = cssText;
      var refNode = element.hasChildNodes() ? element.children[0] : null;
      element.insertBefore( styleElement, refNode );
    }
  }

  function svgString2Image( svgString, width, height, format, callback ) {
    var format = format ? format : 'png';

    //var imgsrc = 'data:image/svg+xml;base64,'+ btoa( unescape( encodeURIComponent( svgString ) ) ); // Convert SVG string to data URL

    var canvas = document.createElement("canvas");
    var context = canvas.getContext("2d");

    canvas.width = width;
    canvas.height = height;

    var image = new Image();
    image.onload = function() {
      console.log("loaded")
      context.clearRect ( 0, 0, width, height );
      context.drawImage(image, 0, 0, width, height);

      canvas.toBlob( function(blob) {
        var filesize = Math.round( blob.length/1024 ) + ' KB';
        if ( callback ) callback( blob, filesize );
      });
    };
    var url = URL.createObjectURL(
      new Blob([svgString], {
        type: 'image/svg+xml;charset=utf8'
        })
    );
    image.src = url;
  }

 function applyColorGradient ( defs, gradient, minValue, maxValue ) {
    if (!gradient.name || !gradient.colors) return {};
    var colors = gradient.colors;
    var colorRange = d3.range(0, 1, 1.0 / (colors.length - 1));
    colorRange.push(1);
           
    var colorScale = d3.scale.linear()
      .domain(colorRange)
      .range(colors)
      .interpolate(d3.interpolateHcl);

    var colorInterpolate = d3.scale.linear()
      .domain([minValue, maxValue])
      .range([0,1]);

    defs.append("linearGradient")
      .attr("id", "gradient-" + gradient.name + "-colors")
      .attr("x1", "0%").attr("y1", "0%")
      .attr("x2", "100%").attr("y2", "0%")
      .selectAll("stop") 
      .data(colors)                  
      .enter().append("stop") 
      .attr("offset", function(d,i) { return i/(colors.length-1); })   
      .attr("stop-color", function(d) { return d; });
    return {colorScale: colorScale, colorInterpolate: colorInterpolate};
  }

  // https://bl.ocks.org/duspviz-mit/9b6dce37101c30ab80d0bf378fe5e583
  function updateColorLegend ( gradientID, width, height, maxValue ) { //     var w = 300, h = 50;
    d3.select("#colorLegend").selectAll("svg").remove();
    var legend = d3.select("#colorLegend")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    legend.append("rect")
      .attr("width", width)
      .attr("height", height - 30)
      .style("fill", "url(#" + gradientID + ")")
      .attr("transform", "translate(0,10)");

    var y = d3.scale.linear()
      .range([500, 0]) // 300, 0
      .domain([maxValue, 10]); // 68, 12

    var yAxis = d3.svg.axis().scale(y).orient("bottom").ticks(5);

    legend.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(0,30)")
      .call(yAxis)
      .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0)
      .attr("dy", ".71em")
      .style("text-anchor", "end");
  }

  function updateColorGradient ( svg, gradient, maxValue ) {
    var gradientID = "gradient-" + gradient.name + "-colors";
    svg.selectAll(".node")
      .transition().duration(1000)
      .style("fill", function (d,i) { var classes = $(this).attr('class'); return (!!classes && classes.split('node--leafnode').length > 1) ? gradient.colorScale(gradient.colorInterpolate(d.data.size)) : color(d.depth); });
    updateColorLegend(gradientID, 300, 50, maxValue);
  }

  function showCitations ( attribute ) {
    if (!attribute || attribute == '') return;
    $.ajax
      ({
        type: "POST",
        url: 'citationsPerAttribute',
        dataType: 'json',
        contentType:'application/json',
        async: true,
        data: JSON.stringify({attribute: attribute}),
        success: function ( citationsPerAttribute ) {
          if (!citationsPerAttribute) {
            handleError('Cannot get citations from DB for attribute: ' + attribute + '.');
            return;
          }
          var citationTable = '<div style="max-height:500px;overflow-y:auto;"><table class="table table-striped"><thead><tr><th>Citation</th><th>References</th><th>Bib</th></tr></thead><tbody>';
          var sumOfReferences = 0;
          if (!!citationsPerAttribute.response) {
            citationsPerAttribute.response.forEach ( function ( citationPerAttribute ) {
              citationTable += '<tr><td>' + citationPerAttribute.citation + '</td><td>' + citationPerAttribute.referenceCount + '</td><td>' + citationPerAttribute.bib + '</td></tr>';
              sumOfReferences += citationPerAttribute.referenceCount;
            });
          }
          citationTable += '</tbody></table></div>';
          if (sumOfReferences > 0) citationTable = '<div><p><b>Sum of references:</b>  ' + sumOfReferences + '</p></div>' + citationTable;
          BootstrapDialog.show({
            title: 'Citations for attribute "' + attribute + '"',
            message: citationTable
          });
        }
      });
  }

  function showHierarchy ( json, minValue, maxValue ) {
    d3.selectAll("svg").remove();
    $('#svgContainer').html('<svg id="circlePackingSVG" width="960" height="960"></svg>');
    var svg = d3.select("svg"),
        margin = 20,
        diameter = svg.attr("width"),
        g = svg.append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

    var d3Tip = d3.tip().attr('class', 'd3-tip').html(function(d) {
      var text = d.data.name;
      if (!!d.data.size) text += ': ' + d.data.size;
      return text;
    });
    svg.call(d3Tip);

    var defs = svg.append("defs");

    COLOR_GRADIENTS.forEach ( function ( gradient ) {
      var result = applyColorGradient(defs, gradient, minValue, maxValue);
      if (!!result) {
        if (!!result.colorScale) gradient.colorScale = result.colorScale;
        if (!!result.colorInterpolate) gradient.colorInterpolate = result.colorInterpolate;
      }
    });

    var pack = d3.pack()
        .size([diameter - margin, diameter - margin])
        .padding(2);

      var rootNode = d3.hierarchy(json)
          .sum(function(d) { return d.size; })
          .sort(function(a, b) { return b.value - a.value; });

      var focus = rootNode,
          nodes = pack(rootNode).descendants(),
          view;

      console.log('nodes: ', nodes);

      var circle = g.selectAll("circle")
        .data(nodes)
        .enter().append("circle")
          .attr("class", function(d) { return d.parent ? (d.data.children && d.data.children.length > 0) ? "node" : "node node--leafnode" : "node node--root"; })
          //.style("fill", function(d) { return (d.children && d.children.length > 0) ? color(d.depth) : 'lightgreen'; })
          .on("click", function(d) { if (focus !== d.parent) zoom(d.parent), d3.event.stopPropagation(); else if ($(this).attr("class").split('node--leafnode').length > 1) showCitations(d.data.name), d3.event.stopPropagation(); else if (focus !== d) zoom(d), d3.event.stopPropagation(); })
          .on("mouseover", function (d) { d3Tip.show(d); })
          .on("mouseout", function (d) { d3Tip.hide(d); });

      var text = g.selectAll("text")
        .data(nodes)
        .enter().append("text")
          .attr("class", "label")
          .style("fill-opacity", function(d) { return d.parent === rootNode ? 1 : 0; })
          .style("display", function(d) { return d.parent === rootNode ? "inline" : "none"; })
          .text(function(d) { return d.data.name; });

      var node = g.selectAll("circle,text");

      svg.style("background", color(-1))
         .on("click", function() { zoom(rootNode); });

      d3.select("body").on("keydown", function( e ) { if (d3.event.keyCode == 27) zoom(!!node.parent ? node.parent : rootNode); }); // escape key

      zoomTo([rootNode.x, rootNode.y, rootNode.r * 2 + margin]);

      function zoom(d) {
        var focus0 = focus; focus = d;

        var transition = d3.transition()
            .duration(d3.event.altKey ? 7500 : 750)
            .tween("zoom", function(d) {
              var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
              return function(t) { zoomTo(i(t)); };
            });

        svg.selectAll("text")
          .filter(function(d) { return d.parent === focus || this.style.display === "inline"; })
          .style("fill-opacity", function(d) { if (d.parent === focus) { this.style.display = "inline"; } else { this.style.display = "none"; } return d.parent === focus ? 1 : 0; })
          //.on("start", function(d) { if (d.parent === focus) this.style.display = "inline"; })
          //.on("end", function(d) { if (d.parent !== focus) this.style.display = "none"; });
      }

      function zoomTo(v) {
        var k = diameter / v[2]; view = v;
        node.attr("transform", function(d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
        circle.attr("r", function(d) { return d.r * k; });
      }
      var colorThemeIndex = $('#colorTheme')[0].value - 0;
      if (!isNaN(colorThemeIndex) && colorThemeIndex >= 0 && colorThemeIndex < COLOR_GRADIENTS.length) updateColorGradient(svg, COLOR_GRADIENTS[colorThemeIndex], maxValue);

      $('#colorTheme').unbind().on('change', function ( e ) {
        var index = this.value - 0;
        if (!isNaN(index) && index >= 0 && index < COLOR_GRADIENTS.length) updateColorGradient(svg, COLOR_GRADIENTS[index], maxValue);
      });
    $('#export').unbind().click ( function () {
      var svg = d3.select("#circlePackingSVG");
      var svgString = getSVGString(svg.node());
      var width = svg.attr('width');
      var height = svg.attr('height');
      svgString2Image( svgString, width*3, height*3, 'png', function ( dataBlob, filesize ) {
        saveAs( dataBlob, 'CirclePacking.png' ); // FileSaver.js function
      }); // passes Blob and filesize String to the callback        
    });
  }

  function traverseTree ( json, attributes, parents, counter, useReferenceCount ) {
    if (attributes.length == 0 || counter > 100) {
      parents.forEach ( function ( parent ) {
        if (!!useReferenceCount) parent.size = !!parent.referenceCountSum ? (parent.referenceCountSum) : 0;
        else parent.size = !!parent.citationCount ? (parent.citationCount) : 0;
      });
      return json;
    }
    var remainingAttributes = [];
    attributes.forEach ( function ( attribute ) {
      var found = false;
      for ( var i = 0; i < parents.length; i++ ) {
        if (parents[i].name.trim() == attribute.parentText.trim()) {
          var obj = {'name': attribute.text, 'children': [], 'citationCount': attribute.citationCount, 'referenceCountSum': attribute.referenceCountSum};
          parents[i].children.push(obj);
          parents.push(obj);
          found = true;
          break;
        }
      }
      if (!found) remainingAttributes.push(attribute);
    });
    return traverseTree(json, remainingAttributes, parents, counter+1, useReferenceCount);
  }

  function createJSON ( dimensions, attributes, relations, relationTypes, citationCounts, useReferenceCount ) {
    isInterDimensional = dimensions.length > 1;

    var json = {'name': 'Taxonomy', 'children': [], 'citationCount': 0, 'referenceCountSum': 0};
    dimensions.forEach ( function ( dimension ) {
      json.children.push({'name': dimension.text, 'children': [], 'citationCount': 0, 'referenceCountSum': 0});
    });
    var remainingAttributes = [];
    var orphanAttributes = [];
    var parents = [];
    var minValue = 0;
    var maxValue = 0;
    attributes.forEach ( function ( attribute ) {
      var found = false;
      for ( var i = 0; i < citationCounts.length; i++ ) {
        if (citationCounts[i].attribute == attribute.text) {
          attribute.citationCount = citationCounts[i].citationCount;
          attribute.referenceCountSum = citationCounts[i].referenceCountSum;
          if (useReferenceCount && attribute.referenceCountSum > maxValue) maxValue = attribute.referenceCountSum;
          else if (!useReferenceCount && attribute.citationCount > maxValue) maxValue = attribute.citationCount;
          found = true;
          break;
        }
      }
      if (!found) {
        attribute.citationCount = 0;
        attribute.referenceCountSum = 0;
      }
      if (!!attribute.parentText) attribute.parentText = attribute.parentText.split(',').shift();
      if (!attribute.dimension || attribute.dimension == '') orphanAttributes.push(attribute);
      else if (!attribute.parentText || attribute.parentText == '') {
        var found = false;
        for ( var i = 0; i < json.children.length; i++ ) {
          if (json.children[i].name.trim() == attribute.dimension.trim()) {
            var obj = {'name': attribute.text, 'children': [], 'citationCount': attribute.citationCount, 'referenceCountSum': attribute.referenceCountSum};
            json.children[i].children.push(obj);
            parents.push(obj);
            found = true;
            break;
          }
        }
        if (!found) remainingAttributes.push(attribute);
      } else remainingAttributes.push(attribute);
    });
    
    orphanAttributes.forEach ( function ( orphan ) {
      var obj = {'name': orphan.text, 'children': [], 'citationCount': orphan.citationCount, 'referenceCountSum': orphan.referenceCountSum};
      json.children.push(obj);
      parents.push(obj);
    });
    json = traverseTree(json, remainingAttributes, parents, 0, useReferenceCount);
    showHierarchy(json, minValue, maxValue);
  }

    function showDimension ( taxonomyID, dimension ) {
      $.get('dimension', function ( dimensionResults ) {
        if (!dimensionResults || !dimensionResults.response) {
          console.log('Cannot get dimensions from DB.');
          return;
        }
        var request = {'taxonomy_id': taxonomyID};
        var attributeURL, attributeRelationsURL, dimensions, ajaxType;
        switch(dimension) {
          case 'Interdimensional view': attributeURL = 'attribute'; ajaxType = 'GET'; attributeRelationsURL = 'interdimensionalRelations'; dimensions = dimensionResults.response; break;
          default: attributeURL = 'attributesPerDimension'; ajaxType = 'POST'; attributeRelationsURL = 'attributeRelations'; dimensions = [{text: dimension}]; request.dimension = dimension;
        }
        $.ajax
          ({
              type: ajaxType,
              //the url where you want to sent the userName and password to
              url: attributeURL,
              dataType: 'json',
              contentType:'application/json',
              async: true,
              //json object to sent to the authentication url
              data: JSON.stringify(request),
              success: function ( attributes ) {
                if (!attributes) {
                  console.log('Cannot get attributes from DB.');
                  return;
                }
                $.ajax
                  ({
                      type: "POST",
                      //the url where you want to sent the userName and password to
                      url: attributeRelationsURL,
                      dataType: 'json',
                      contentType:'application/json',
                      async: true,
                      //json object to sent to the authentication url
                      data: JSON.stringify(request),
                      success: function ( relations ) {
                        if (!relations) {
                          console.log('Cannot get attribute relations from DB.');
                          return;
                        }
                        $.get('relationTypes', function ( relationTypes ) {
                          if (!relationTypes) {
                            console.log('Cannot get relation types from DB.');
                            return;
                          }
                          $.get('citationCounts', function ( citationCounts ) {
                              if (!citationCounts) {
                                console.log('Cannot get citation counts from DB.');
                                return;
                              }
                              $('#colorTheme').html('');
                              for ( var i = 0; i < COLOR_GRADIENTS.length; i++ ) {
                                $('#colorTheme').append('<option value="' + i + '">' + COLOR_GRADIENTS[i].name + '</option>');
                              }
                              $('#dataType').unbind().on('change', function () {
                                createJSON(dimensions, !!attributes.response ? attributes.response : [], !!relations.response ? relations.response : [], !!relationTypes.response ? relationTypes.response : [], !!citationCounts.response ? citationCounts.response : [], this.value == 'referenceCount');
                              });
                              createJSON(dimensions, !!attributes.response ? attributes.response : [], !!relations.response ? relations.response : [], !!relationTypes.response ? relationTypes.response : [], !!citationCounts.response ? citationCounts.response : [], $('#dataType').val() == 'referenceCount');
                              displayedDimension = dimension;
                          });
                        });
                      }
                  });
              }
          });
      });
    }

    function showDimensionRelations () {
      var request = {'taxonomy_id': taxonomyID};
      $.ajax
        ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: 'dimensionMajorAttributes',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify(request),
            success: function ( majorAttributes ) {
              showDimensions(majorAttributes.response);
            }
        });
    }

    $(document).ready( function () {
      var taxonomyID = 1;
      var dimension = window.location.href.split('#').pop().replace(/%20/g, ' ');
      if (dimension != '') {
        console.log('dimension: ' + dimension);
        showDimension(taxonomyID, dimension);
      }
    });
	</script>
</body>
</html>

