<!doctype html>
<html>
<head>
    <title>Treemap</title>
    <script src="jquery.min.js"></script>
    <script type="text/javascript" src="d3.v4.min.js"></script>
    <script type="text/javascript" src="d3-hierarchy.v1.min.js"></script>

    <link href="bootstrap.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap.min.js"></script>

    <link href="bootstrap-dialog.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap-dialog.min.js"></script>

    <script src="multiselect.min.js"></script>

    <link href="loginForm.css" type="text/css" rel="stylesheet"/>

    <!-- promises -->
    <script src="bluebird.min.js"></script>
    <script src="error.js"></script>
    <style>

    body {
      font: 10px sans-serif;
      position: relative;
    }

    .node {
      box-sizing: border-box;
      position: absolute;
      overflow: hidden;
    }

    .node-label {
      padding: 4px;
      line-height: 1em;
      white-space: pre;
    }

    .node-value {
      color: rgba(0,0,0,0.8);
      font-size: 9px;
      margin-top: 1px;
    }

    </style>
</head>
<body>
  <svg width="960" height="960"></svg>
<script>

  var isInterDimensional = true;
  var displayedDimension;

  function showHierarchy ( json ) {
    var svg = d3.select("svg"),
        margin = 20,
        diameter = svg.attr("width"),
        g = svg.append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")");

    var color = d3.scaleLinear()
        .domain([-1, 5])
        .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
        .interpolate(d3.interpolateHcl);

    var width = 960,
      height = 1060;


    var format = d3.format(",d");

    var color = d3.scaleOrdinal()
        .range(d3.schemeCategory10
            .map(function(c) { c = d3.rgb(c); c.opacity = 0.6; return c; }));

    //var stratify = d3.stratify()
    //    .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });

    var treemap = d3.treemap()
      .size([width, height])
      .padding(1)
      .round(true);

      var rootNode = d3.hierarchy(json)
          .sum(function(d) { return d.value; })
          .sort(function(a, b) { return b.height - a.height || b.value - a.value; });

     treemap(rootNode);

    d3.select("body")
      .selectAll(".node")
      .data(rootNode.leaves())
      .enter().append("div")
        .attr("class", "node")
        .attr("title", function(d) { return d.id + "\n" + format(d.value); })
        .style("left", function(d) { return d.x0 + "px"; })
        .style("top", function(d) { return d.y0 + "px"; })
        .style("width", function(d) { return d.x1 - d.x0 + "px"; })
        .style("height", function(d) { return d.y1 - d.y0 + "px"; })
        .style("background", function(d) { while (d.depth > 1) d = d.parent; return color(d.id); })
      .append("div")
        .attr("class", "node-label")
        .text(function(d) { return d.data.name; })
      .append("div")
        .attr("class", "node-value")
        .text(function(d) { return format(d.value); });
  }

  function traverseTree ( json, attributes, parents, counter ) {
    if (attributes.length == 0 || counter > 100) {
      parents.forEach ( function ( parent ) {
        console.log('cit: ', parent.citationCount)
        parent.size = !!parent.citationCount ? (parent.citationCount * 10) : (parent.children.length > 0 ? 100 * parent.children.length : 100);
      })
      return json;
    }
    var remainingAttributes = [];
    attributes.forEach ( function ( attribute ) {
      var found = false;
      for ( var i = 0; i < parents.length; i++ ) {
        if (parents[i].name.trim() == attribute.parentText.trim()) {
          var obj = {'name': attribute.text, 'children': [], 'citationCount': attribute.citationCount};
          parents[i].children.push(obj);
          parents.push(obj);
          found = true;
          break;
        }
      }
      if (!found) remainingAttributes.push(attribute);
    });
    return traverseTree(json, remainingAttributes, parents, counter+1);
  }

  function createJSON ( dimensions, attributes, relations, relationTypes, citationCounts ) {
    console.log('creating json, sttr: ', attributes);
    isInterDimensional = dimensions.length > 1;

    var json = {'name': 'Taxonomy', 'children': [], 'citationCount': 0};
    dimensions.forEach ( function ( dimension ) {
      json.children.push({'name': dimension.text, 'children': [], 'citationCount': 0, 'size': 1000});
    });
    var remainingAttributes = [];
    var orphanAttributes = [];
    var parents = [];
    attributes.forEach ( function ( attribute ) {
      var found = false;
      for ( var i = 0; i < citationCounts.length; i++ ) {
        if (citationCounts[i].attribute == attribute.text) {
          attribute.citationCount = citationCounts[i].citationCount;
          found = true;
          break;
        }
      }
      if (!found) {
        attribute.citationCount = 0;
      }
      if (!!attribute.parentText) attribute.parentText = attribute.parentText.split(',').shift();
      if (!attribute.dimension || attribute.dimension == '') orphanAttributes.push(attribute);
      else if (!attribute.parentText || attribute.parentText == '') {
        var found = false;
        for ( var i = 0; i < json.children.length; i++ ) {
          if (json.children[i].name.trim() == attribute.dimension.trim()) {
            var obj = {'name': attribute.text, 'children': [], 'citationCount': attribute.citationCount};
            json.children[i].children.push(obj);
            parents.push(obj);
            found = true;
            break;
          }
        }
        if (!found) remainingAttributes.push(attribute);
      } else remainingAttributes.push(attribute);
    });
    
    orphanAttributes.forEach ( function ( orphan ) {
      var obj = {'name': orphan.text, 'children': [], 'citationCount': orphan.citationCount};
      json.children.push(obj);
      parents.push(obj);
    });
    
    json = traverseTree(json, remainingAttributes, parents, 0);
    showHierarchy(json);
  }

    function showDimension ( taxonomyID, dimension ) {
      $.get('dimension', function ( dimensionResults ) {
        if (!dimensionResults || !dimensionResults.response) {
          console.log('Cannot get dimensions from DB.');
          return;
        }
        var request = {'taxonomy_id': taxonomyID};
        var attributeURL, attributeRelationsURL, dimensions, ajaxType;
        switch(dimension) {
          case 'Interdimensional view': attributeURL = 'attribute'; ajaxType = 'GET'; attributeRelationsURL = 'interdimensionalRelations'; dimensions = dimensionResults.response; break;
          default: attributeURL = 'attributesPerDimension'; ajaxType = 'POST'; attributeRelationsURL = 'attributeRelations'; dimensions = [{text: dimension}]; request.dimension = dimension;
        }
        $.ajax
          ({
              type: ajaxType,
              //the url where you want to sent the userName and password to
              url: attributeURL,
              dataType: 'json',
              contentType:'application/json',
              async: true,
              //json object to sent to the authentication url
              data: JSON.stringify(request),
              success: function ( attributes ) {
                if (!attributes) {
                  console.log('Cannot get attributes from DB.');
                  return;
                }
                console.log(attributes.response)
                $.ajax
                  ({
                      type: "POST",
                      //the url where you want to sent the userName and password to
                      url: attributeRelationsURL,
                      dataType: 'json',
                      contentType:'application/json',
                      async: true,
                      //json object to sent to the authentication url
                      data: JSON.stringify(request),
                      success: function ( relations ) {
                        if (!relations) {
                          console.log('Cannot get attribute relations from DB.');
                          return;
                        }
                        $.get('relationTypes', function ( relationTypes ) {
                          if (!relationTypes) {
                            console.log('Cannot get relation types from DB.');
                            return;
                          }
                          $.get('citationCounts', function ( citationCounts ) {
                              if (!citationCounts) {
                                console.log('Cannot get citation counts from DB.');
                                return;
                              }
                              createJSON(dimensions, !!attributes.response ? attributes.response : [], !!relations.response ? relations.response : [], !!relationTypes.response ? relationTypes.response : [], !!citationCounts.response ? citationCounts.response : []);
                              displayedDimension = dimension;
                          });
                        });
                      }
                  });
              }
          });
      });
    }

    function showDimensionRelations () {
      var request = {'taxonomy_id': taxonomyID};
      $.ajax
        ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: 'dimensionMajorAttributes',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify(request),
            success: function ( majorAttributes ) {
              showDimensions(majorAttributes.response);
            }
        });
    }

    $(document).ready( function () {
      var taxonomyID = 1;
      var dimension = window.location.href.split('#').pop().replace(/%20/g, ' ');
      if (dimension != '') {
        console.log('dimension: ' + dimension);
        showDimension(taxonomyID, dimension);
      }
    });
	</script>
</body>
</html>

