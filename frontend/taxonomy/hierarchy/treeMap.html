<!doctype html>
<html>
<head>
    <title>Treemap</title>
    <script src="jquery.min.js"></script>
    <script type="text/javascript" src="d3.v4.min.js"></script>
    <script type="text/javascript" src="d3-hierarchy.v1.min.js"></script>

    <link href="bootstrap.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap.min.js"></script>

    <link href="bootstrap-dialog.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap-dialog.min.js"></script>

    <script src="multiselect.min.js"></script>

    <link href="loginForm.css" type="text/css" rel="stylesheet"/>

    <!-- promises -->
    <script src="bluebird.min.js"></script>
    <script src="error.js"></script>
    <style>

    body {
      font: 10px sans-serif;
      position: relative;
    }

    .node {
      box-sizing: border-box;
      position: absolute;
      overflow: hidden;
    }

    .node-label {
      padding: 4px;
      line-height: 1em;
      white-space: pre;
    }

    .node-value {
      color: rgba(0,0,0,0.8);
      font-size: 9px;
      margin-top: 1px;
    }

    </style>
</head>
<body>
<script>

  var isInterDimensional = true;
  var displayedDimension;

  function showHierarchy ( json ) {

    var width = 960,
        height = 1060;

    var format = d3.format(",d");

    var color = d3.scaleOrdinal()
        .range(d3.schemeCategory10
            .map(function(c) { c = d3.rgb(c); c.opacity = 0.6; return c; }));

    var stratify = d3.stratify()
        .parentId(function(d) { return d.data.name.substring(0, d.data.name.lastIndexOf(".")); });

    var treemap = d3.treemap()
        .size([width, height])
        .padding(1)
        .round(true);


      var rootNode = d3.hierarchy(json)
          .sum(function(d) { return d.size; })
          .sort(function(a, b) { return b.height - a.height || b.size - a.size; });

      treemap(rootNode);

      var focus = rootNode,
        nodes = rootNode.leaves(),
        view;

      d3.select("body")
        .selectAll(".node")
        .data(rootNode.leaves())
        .enter().append("div")
          .attr("class", "node")
          .attr("title", function(d) { return d.data.name; })
          .style("left", function(d) { return d.x0 + "px"; })
          .style("top", function(d) { return d.y0 + "px"; })
          .style("width", function(d) { return d.x1 - d.x0 + "px"; })
          .style("height", function(d) { return d.y1 - d.y0 + "px"; })
          .style("background", function(d) { while (d.depth > 1) d = d.parent; return color(d.data.name); })
          .on("click", function(d) { if (focus !== d.parent) zoom(d.parent), d3.event.stopPropagation(); else if ($(this).attr("class").split('node--leafnode').length > 1) showCitations(d.data.name), d3.event.stopPropagation(); else if (focus !== d) zoom(d), d3.event.stopPropagation(); })
        .append("div")
          .attr("class", "node-label")
          .text(function(d) { return d.data.name; })
        .append("div")
          .attr("class", "node-value")
          .text(function(d) { return format(d.data.size); });

    function type(d) {
      d.size = +d.size;
      return d;
    }

    var svg = d3.select("svg");

    var margin = 20;
    var diameter = svg.attr("width");

    svg.style("background", color(-1))
       .on("click", function() { zoom(rootNode); });

    zoomTo([rootNode.x, rootNode.y]);

    function zoom(d) {
      var focus0 = focus; focus = d;

      var transition = d3.transition()
          .duration(d3.event.altKey ? 7500 : 750)
          .tween("zoom", function(d) {
            var i = d3.interpolateZoom(view, [focus.x, focus.y]);
            return function(t) { zoomTo(i(t)); };
          });

      svg.selectAll("text")
        .filter(function(d) { return d.parent === focus || this.style.display === "inline"; })
        .style("fill-opacity", function(d) { if (d.parent === focus) { this.style.display = "inline"; } else { this.style.display = "none"; } return d.parent === focus ? 1 : 0; })
        //.on("start", function(d) { if (d.parent === focus) this.style.display = "inline"; })
        //.on("end", function(d) { if (d.parent !== focus) this.style.display = "none"; });
    }

    function zoomTo(v) {
      var k = diameter / v[2]; view = v;
      node.attr("transform", function(d) { return "translate(" + (d.x - v[0]) * k + "," + (d.y - v[1]) * k + ")"; });
      
    }
  }

  function traverseTree ( json, attributes, parents, counter ) {
    if (attributes.length == 0 || counter > 100) {
      parents.forEach ( function ( parent ) {
        parent.size = !!parent.citationCount ? (parent.citationCount * 10) : (parent.children.length > 0 ? 100 * parent.children.length : 100);
      })
      return json;
    }
    var remainingAttributes = [];
    attributes.forEach ( function ( attribute ) {
      var found = false;
      for ( var i = 0; i < parents.length; i++ ) {
        if (parents[i].name.trim() == attribute.parentText.trim()) {
          var obj = {'name': attribute.text, 'children': [], 'citationCount': attribute.citationCount};
          parents[i].children.push(obj);
          parents.push(obj);
          found = true;
          break;
        }
      }
      if (!found) remainingAttributes.push(attribute);
    });
    return traverseTree(json, remainingAttributes, parents, counter+1);
  }

  function createJSON ( dimensions, attributes, relations, relationTypes, citationCounts ) {
    console.log('creating json, sttr: ', attributes);
    isInterDimensional = dimensions.length > 1;

    var json = {'name': 'Taxonomy', 'children': [], 'citationCount': 0};
    dimensions.forEach ( function ( dimension ) {
      json.children.push({'name': dimension.text, 'children': [], 'citationCount': 0, 'size': 1000});
    });
    var remainingAttributes = [];
    var orphanAttributes = [];
    var parents = [];
    attributes.forEach ( function ( attribute ) {
      var found = false;
      for ( var i = 0; i < citationCounts.length; i++ ) {
        if (citationCounts[i].attribute == attribute.text) {
          attribute.citationCount = citationCounts[i].citationCount;
          found = true;
          break;
        }
      }
      if (!found) {
        attribute.citationCount = 0;
      }
      if (!!attribute.parentText) attribute.parentText = attribute.parentText.split(',').shift();
      if (!attribute.dimension || attribute.dimension == '') orphanAttributes.push(attribute);
      else if (!attribute.parentText || attribute.parentText == '') {
        var found = false;
        for ( var i = 0; i < json.children.length; i++ ) {
          if (json.children[i].name.trim() == attribute.dimension.trim()) {
            var obj = {'name': attribute.text, 'children': [], 'citationCount': attribute.citationCount};
            json.children[i].children.push(obj);
            parents.push(obj);
            found = true;
            break;
          }
        }
        if (!found) remainingAttributes.push(attribute);
      } else remainingAttributes.push(attribute);
    });
    
    orphanAttributes.forEach ( function ( orphan ) {
      var obj = {'name': orphan.text, 'children': [], 'citationCount': orphan.citationCount};
      json.children.push(obj);
      parents.push(obj);
    });
    
    json = traverseTree(json, remainingAttributes, parents, 0);
    showHierarchy(json);
  }

    function showDimension ( taxonomyID, dimension ) {
      $.get('dimension', function ( dimensionResults ) {
        if (!dimensionResults || !dimensionResults.response) {
          console.log('Cannot get dimensions from DB.');
          return;
        }
        var request = {'taxonomy_id': taxonomyID};
        var attributeURL, attributeRelationsURL, dimensions, ajaxType;
        switch(dimension) {
          case 'Interdimensional view': attributeURL = 'attribute'; ajaxType = 'GET'; attributeRelationsURL = 'interdimensionalRelations'; dimensions = dimensionResults.response; break;
          default: attributeURL = 'attributesPerDimension'; ajaxType = 'POST'; attributeRelationsURL = 'attributeRelations'; dimensions = [{text: dimension}]; request.dimension = dimension;
        }
        $.ajax
          ({
              type: ajaxType,
              //the url where you want to sent the userName and password to
              url: attributeURL,
              dataType: 'json',
              contentType:'application/json',
              async: true,
              //json object to sent to the authentication url
              data: JSON.stringify(request),
              success: function ( attributes ) {
                if (!attributes) {
                  console.log('Cannot get attributes from DB.');
                  return;
                }
                console.log(attributes.response)
                $.ajax
                  ({
                      type: "POST",
                      //the url where you want to sent the userName and password to
                      url: attributeRelationsURL,
                      dataType: 'json',
                      contentType:'application/json',
                      async: true,
                      //json object to sent to the authentication url
                      data: JSON.stringify(request),
                      success: function ( relations ) {
                        if (!relations) {
                          console.log('Cannot get attribute relations from DB.');
                          return;
                        }
                        $.get('relationTypes', function ( relationTypes ) {
                          if (!relationTypes) {
                            console.log('Cannot get relation types from DB.');
                            return;
                          }
                          $.get('citationCounts', function ( citationCounts ) {
                              if (!citationCounts) {
                                console.log('Cannot get citation counts from DB.');
                                return;
                              }
                              createJSON(dimensions, !!attributes.response ? attributes.response : [], !!relations.response ? relations.response : [], !!relationTypes.response ? relationTypes.response : [], !!citationCounts.response ? citationCounts.response : []);
                              displayedDimension = dimension;
                          });
                        });
                      }
                  });
              }
          });
      });
    }

    function showDimensionRelations () {
      var request = {'taxonomy_id': taxonomyID};
      $.ajax
        ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: 'dimensionMajorAttributes',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify(request),
            success: function ( majorAttributes ) {
              showDimensions(majorAttributes.response);
            }
        });
    }

    $(document).ready( function () {
      var taxonomyID = 1;
      var dimension = window.location.href.split('#').pop().replace(/%20/g, ' ');
      if (dimension != '') {
        console.log('dimension: ' + dimension);
        showDimension(taxonomyID, dimension);
      }
    });
	</script>
</body>
</html>

