<!doctype html>
<html>
<head>
    <title>Treemap</title>
    <script src="jquery.min.js"></script>
    <script type="text/javascript" src="d3.min.js"></script>
    <script type="text/javascript" src="d3.layout.js"></script>
    <script type="text/javascript" src="d3-hierarchy.v1.min.js"></script>

    <link href="bootstrap.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap.min.js"></script>

    <link href="bootstrap-dialog.min.css" type="text/css" rel="stylesheet"/>
    <script src="bootstrap-dialog.min.js"></script>

    <script src="multiselect.min.js"></script>

    <link href="loginForm.css" type="text/css" rel="stylesheet"/>

    <!-- promises -->
    <script src="bluebird.min.js"></script>
    <script src="error.js"></script>
    <style>

    body {
      font: 10px sans-serif;
      position: relative;
    }

    .node {
      box-sizing: border-box;
      position: absolute;
      overflow: hidden;
    }

    .node-label {
      padding: 4px;
      line-height: 1em;
      white-space: pre;
    }

    .node-value {
      color: rgba(0,0,0,0.8);
      font-size: 9px;
      margin-top: 1px;
    }

    </style>
</head>
<body>
  <div><select>
    <option value="size">Size</option>
    <option value="count">Count</option>
  </select></div>
<script>

  var isInterDimensional = true;
  var displayedDimension;

  function showCitations ( attribute ) {
    if (!attribute || attribute == '') return;
    $.ajax
      ({
        type: "POST",
        url: 'citationsPerAttribute',
        dataType: 'json',
        contentType:'application/json',
        async: true,
        data: JSON.stringify({attribute: attribute}),
        success: function ( citationsPerAttribute ) {
          if (!citationsPerAttribute) {
            handleError('Cannot get citations from DB for attribute: ' + attribute + '.');
            return;
          }
          var citationTable = '<div style="max-height:500px;overflow-y:auto;"><table class="table table-striped"><thead><tr><th>Citation</th><th>Occurrences</th><th>References</th><th>Bib</th></tr></thead><tbody>';
          var sumOfReferences = 0;
          if (!!citationsPerAttribute.response) {
            citationsPerAttribute.response.forEach ( function ( citationPerAttribute ) {
              citationTable += '<tr><td>' + citationPerAttribute.citation + '</td><td>' + citationPerAttribute.occurrenceCount + '</td><td>' + citationPerAttribute.referenceCount + '</td><td>' + citationPerAttribute.bib + '</td></tr>';
              sumOfReferences += citationPerAttribute.referenceCount;
            });
          }
          citationTable += '</tbody></table></div>';
          if (sumOfReferences > 0) citationTable = '<div><p><b>Sum of references:</b>  ' + sumOfReferences + '</p></div>' + citationTable;
          BootstrapDialog.show({
            title: 'Citations for attribute "' + attribute + '"',
            message: citationTable
          });
        }
      });
  }

  function showHierarchy ( json ) {

    var w = 1280 - 80,
        h = 800 - 180,
        x = d3.scale.linear().range([0, w]),
        y = d3.scale.linear().range([0, h]),
        color = d3.scale.category20c(),
        rootNode,
        node;

    var treemap = d3.treemap()
        .size([w, h])
        .tile(d3.treemapBinary);

    var svg = d3.select("body").append("div")
        .attr("class", "chart")
        .style("width", w + "px")
        .style("height", h + "px")
      .append("svg:svg")
        .attr("width", w)
        .attr("height", h)
      .append("svg:g")
        .attr("transform", "translate(.5,.5)");

    rootNode = d3.hierarchy(json)
      .sum(function(d) { return d.size; })
      .sort(function(a, b) { return b.height - a.height || b.size - a.size; });

    treemap(rootNode);

    node = rootNode;

    var nodes = rootNode.children;
    console.log(nodes)

    function updateTreemap ( nodes ) {
      svg.selectAll("g").remove();
      var cell = svg.selectAll("g")
          .data(nodes)
        .enter().append("svg:g")
          .attr("class", "cell")
          .attr("transform", function(d) { return "translate(" + d.x0 + "," + d.y0 + ")"; })
          .on("click", function(d) { var target = node == d ? (!!d.parent ? d.parent : rootNode) : (!!d.children && d.children.length > 0 ? d : null); if (!!target) return zoom(target), d3.event.stopPropagation(); else showCitations(d.data.name), d3.event.stopPropagation(); }); // node == d.parent ? rootNode : d.parent

      cell.append("svg:rect")
          .attr("width", function(d) { return (d.x1 - d.x0) - 1; })
          .attr("height", function(d) { return (d.y1 - d.y0) - 1; })
          .style("fill", function(d) { return !!d.parent ? color(d.parent.data.name) : color(d.data.name); });

      cell.append("svg:text")
          .attr("x", function(d) { return (d.x1 - d.x0) / 2; })
          .attr("y", function(d) { return (d.y1 - d.y0) / 2; })
          .attr("dy", ".35em")
          .attr("text-anchor", "middle")
          .text(function(d) { return d.data.name; })
          .style("opacity", function(d) { d.w = this.getComputedTextLength(); return (d.x1 - d.x0) > d.w ? 1 : 0; });
    }
    updateTreemap(nodes);

    d3.select("body").on("keydown", function( e ) { if (d3.event.keyCode == 27) zoom(!!node.parent ? node.parent : rootNode); }); // escape key

    d3.select("select").on("change", function() {
      treemap.value(this.value == "size" ? size : count).nodes(rootNode);
      zoom(node);
    });

    function size(d) {
      return d.data.size;
    }

    function count(d) {
      return 1;
    }

    function zoom(d) {
      updateTreemap(d.children);
      var kx = w / (d.x1 - d.x0), ky = h / (d.y1 - d.y0);
      x.domain([d.x0, d.x0 + (d.x1 - d.x0)]);
      y.domain([d.y0, d.y0 + (d.y1 - d.y0)]);

      var t = svg.selectAll("g.cell").transition()
          .duration(d3.event.altKey ? 7500 : 750)
          .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.y0) + ")"; });

      t.select("rect")
          .attr("width", function(d) { return kx * (d.x1 - d.x0) - 1; })
          .attr("height", function(d) { return ky * (d.y1 - d.y0) - 1; })

      t.select("text")
          .attr("x", function(d) { return kx * (d.x1 - d.x0) / 2; })
          .attr("y", function(d) { return ky * (d.y1 - d.y0) / 2; })
          .style("opacity", function(d) { return kx * (d.x1 - d.x0) > d.w ? 1 : 0; });

      node = d;
      d3.event.stopPropagation();
    }

  }

  function traverseTree ( json, attributes, parents, counter ) {
    if (attributes.length == 0 || counter > 100) {
      parents.forEach ( function ( parent ) {
        parent.size = !!parent.citationCount ? (parent.citationCount * 10) : (parent.children.length > 0 ? 100 * parent.children.length : 100);
        parent.value = parent.size;
      })
      return json;
    }
    var remainingAttributes = [];
    attributes.forEach ( function ( attribute ) {
      var found = false;
      for ( var i = 0; i < parents.length; i++ ) {
        if (parents[i].name.trim() == attribute.parentText.trim()) {
          var obj = {'name': attribute.text, 'children': [], 'citationCount': attribute.citationCount};
          parents[i].children.push(obj);
          parents.push(obj);
          found = true;
          break;
        }
      }
      if (!found) remainingAttributes.push(attribute);
    });
    return traverseTree(json, remainingAttributes, parents, counter+1);
  }

  function createJSON ( dimensions, attributes, relations, relationTypes, citationCounts ) {
    console.log('creating json, sttr: ', attributes);
    isInterDimensional = dimensions.length > 1;

    var json = {'name': 'Taxonomy', 'children': [], 'citationCount': 0};
    dimensions.forEach ( function ( dimension ) {
      json.children.push({'name': dimension.text, 'children': [], 'citationCount': 0, 'size': 1000});
    });
    var remainingAttributes = [];
    var orphanAttributes = [];
    var parents = [];
    attributes.forEach ( function ( attribute ) {
      var found = false;
      for ( var i = 0; i < citationCounts.length; i++ ) {
        if (citationCounts[i].attribute == attribute.text) {
          attribute.citationCount = citationCounts[i].citationCount;
          found = true;
          break;
        }
      }
      if (!found) {
        attribute.citationCount = 0;
      }
      if (!!attribute.parentText) attribute.parentText = attribute.parentText.split(',').shift();
      if (!attribute.dimension || attribute.dimension == '') orphanAttributes.push(attribute);
      else if (!attribute.parentText || attribute.parentText == '') {
        var found = false;
        for ( var i = 0; i < json.children.length; i++ ) {
          if (json.children[i].name.trim() == attribute.dimension.trim()) {
            var obj = {'name': attribute.text, 'children': [], 'citationCount': attribute.citationCount};
            json.children[i].children.push(obj);
            parents.push(obj);
            found = true;
            break;
          }
        }
        if (!found) remainingAttributes.push(attribute);
      } else remainingAttributes.push(attribute);
    });
    
    orphanAttributes.forEach ( function ( orphan ) {
      var obj = {'name': orphan.text, 'children': [], 'citationCount': orphan.citationCount};
      json.children.push(obj);
      parents.push(obj);
    });
    
    json = traverseTree(json, remainingAttributes, parents, 0);
    showHierarchy(json);
  }

    function showDimension ( taxonomyID, dimension ) {
      $.get('dimension', function ( dimensionResults ) {
        if (!dimensionResults || !dimensionResults.response) {
          console.log('Cannot get dimensions from DB.');
          return;
        }
        var request = {'taxonomy_id': taxonomyID};
        var attributeURL, attributeRelationsURL, dimensions, ajaxType;
        switch(dimension) {
          case 'Interdimensional view': attributeURL = 'attribute'; ajaxType = 'GET'; attributeRelationsURL = 'interdimensionalRelations'; dimensions = dimensionResults.response; break;
          default: attributeURL = 'attributesPerDimension'; ajaxType = 'POST'; attributeRelationsURL = 'attributeRelations'; dimensions = [{text: dimension}]; request.dimension = dimension;
        }
        $.ajax
          ({
              type: ajaxType,
              //the url where you want to sent the userName and password to
              url: attributeURL,
              dataType: 'json',
              contentType:'application/json',
              async: true,
              //json object to sent to the authentication url
              data: JSON.stringify(request),
              success: function ( attributes ) {
                if (!attributes) {
                  console.log('Cannot get attributes from DB.');
                  return;
                }
                console.log(attributes.response)
                $.ajax
                  ({
                      type: "POST",
                      //the url where you want to sent the userName and password to
                      url: attributeRelationsURL,
                      dataType: 'json',
                      contentType:'application/json',
                      async: true,
                      //json object to sent to the authentication url
                      data: JSON.stringify(request),
                      success: function ( relations ) {
                        if (!relations) {
                          console.log('Cannot get attribute relations from DB.');
                          return;
                        }
                        $.get('relationTypes', function ( relationTypes ) {
                          if (!relationTypes) {
                            console.log('Cannot get relation types from DB.');
                            return;
                          }
                          $.get('citationCounts', function ( citationCounts ) {
                              if (!citationCounts) {
                                console.log('Cannot get citation counts from DB.');
                                return;
                              }
                              createJSON(dimensions, !!attributes.response ? attributes.response : [], !!relations.response ? relations.response : [], !!relationTypes.response ? relationTypes.response : [], !!citationCounts.response ? citationCounts.response : []);
                              displayedDimension = dimension;
                          });
                        });
                      }
                  });
              }
          });
      });
    }

    function showDimensionRelations () {
      var request = {'taxonomy_id': taxonomyID};
      $.ajax
        ({
            type: "POST",
            //the url where you want to sent the userName and password to
            url: 'dimensionMajorAttributes',
            dataType: 'json',
            contentType:'application/json',
            async: true,
            //json object to sent to the authentication url
            data: JSON.stringify(request),
            success: function ( majorAttributes ) {
              showDimensions(majorAttributes.response);
            }
        });
    }

    $(document).ready( function () {
      var taxonomyID = 1;
      var dimension = window.location.href.split('#').pop().replace(/%20/g, ' ');
      if (dimension != '') {
        console.log('dimension: ' + dimension);
        showDimension(taxonomyID, dimension);
      }
    });
	</script>
</body>
</html>

